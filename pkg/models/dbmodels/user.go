// Code generated by SQLBoiler 4.6.0 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package dbmodels

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/volatiletech/null/v8"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/strmangle"
)

// User is an object representing the database table.
type User struct {
	ImpartWealthID   string      `boil:"impart_wealth_id" json:"impart_wealth_id" toml:"impart_wealth_id" yaml:"impart_wealth_id"`
	AuthenticationID string      `boil:"authentication_id" json:"authentication_id" toml:"authentication_id" yaml:"authentication_id"`
	Email            string      `boil:"email" json:"email" toml:"email" yaml:"email"`
	ScreenName       string      `boil:"screen_name" json:"screen_name" toml:"screen_name" yaml:"screen_name"`
	CreatedAt        time.Time   `boil:"created_at" json:"created_at" toml:"created_at" yaml:"created_at"`
	UpdatedAt        time.Time   `boil:"updated_at" json:"updated_at" toml:"updated_at" yaml:"updated_at"`
	DeletedAt        null.Time   `boil:"deleted_at" json:"deleted_at,omitempty" toml:"deleted_at" yaml:"deleted_at,omitempty"`
	DeviceToken      string      `boil:"device_token" json:"device_token" toml:"device_token" yaml:"device_token"`
	AwsSNSAppArn     string      `boil:"aws_sns_app_arn" json:"aws_sns_app_arn" toml:"aws_sns_app_arn" yaml:"aws_sns_app_arn"`
	Admin            bool        `boil:"admin" json:"admin" toml:"admin" yaml:"admin"`
	EmailVerified    bool        `boil:"email_verified" json:"email_verified" toml:"email_verified" yaml:"email_verified"`
	Blocked          bool        `boil:"blocked" json:"blocked" toml:"blocked" yaml:"blocked"`
	Feedback         null.String `boil:"feedback" json:"feedback,omitempty" toml:"feedback" yaml:"feedback,omitempty"`
	LastloginAt      null.Time   `boil:"lastlogin_at" json:"lastlogin_at,omitempty" toml:"lastlogin_at" yaml:"lastlogin_at,omitempty"`
	SuperAdmin       bool        `boil:"super_admin" json:"super_admin" toml:"super_admin" yaml:"super_admin"`
	DeletedByAdmin   bool        `boil:"deleted_by_admin" json:"deleted_by_admin" toml:"deleted_by_admin" yaml:"deleted_by_admin"`
	PlaidAccessToken null.String `boil:"plaid_access_token" json:"plaid_access_token,omitempty" toml:"plaid_access_token" yaml:"plaid_access_token,omitempty"`

	R *userR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L userL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var UserColumns = struct {
	ImpartWealthID   string
	AuthenticationID string
	Email            string
	ScreenName       string
	CreatedAt        string
	UpdatedAt        string
	DeletedAt        string
	DeviceToken      string
	AwsSNSAppArn     string
	Admin            string
	EmailVerified    string
	Blocked          string
	Feedback         string
	LastloginAt      string
	SuperAdmin       string
	DeletedByAdmin   string
	PlaidAccessToken string
}{
	ImpartWealthID:   "impart_wealth_id",
	AuthenticationID: "authentication_id",
	Email:            "email",
	ScreenName:       "screen_name",
	CreatedAt:        "created_at",
	UpdatedAt:        "updated_at",
	DeletedAt:        "deleted_at",
	DeviceToken:      "device_token",
	AwsSNSAppArn:     "aws_sns_app_arn",
	Admin:            "admin",
	EmailVerified:    "email_verified",
	Blocked:          "blocked",
	Feedback:         "feedback",
	LastloginAt:      "lastlogin_at",
	SuperAdmin:       "super_admin",
	DeletedByAdmin:   "deleted_by_admin",
	PlaidAccessToken: "plaid_access_token",
}

var UserTableColumns = struct {
	ImpartWealthID   string
	AuthenticationID string
	Email            string
	ScreenName       string
	CreatedAt        string
	UpdatedAt        string
	DeletedAt        string
	DeviceToken      string
	AwsSNSAppArn     string
	Admin            string
	EmailVerified    string
	Blocked          string
	Feedback         string
	LastloginAt      string
	SuperAdmin       string
	DeletedByAdmin   string
	PlaidAccessToken string
}{
	ImpartWealthID:   "user.impart_wealth_id",
	AuthenticationID: "user.authentication_id",
	Email:            "user.email",
	ScreenName:       "user.screen_name",
	CreatedAt:        "user.created_at",
	UpdatedAt:        "user.updated_at",
	DeletedAt:        "user.deleted_at",
	DeviceToken:      "user.device_token",
	AwsSNSAppArn:     "user.aws_sns_app_arn",
	Admin:            "user.admin",
	EmailVerified:    "user.email_verified",
	Blocked:          "user.blocked",
	Feedback:         "user.feedback",
	LastloginAt:      "user.lastlogin_at",
	SuperAdmin:       "user.super_admin",
	DeletedByAdmin:   "user.deleted_by_admin",
	PlaidAccessToken: "user.plaid_access_token",
}

// Generated where

var UserWhere = struct {
	ImpartWealthID   whereHelperstring
	AuthenticationID whereHelperstring
	Email            whereHelperstring
	ScreenName       whereHelperstring
	CreatedAt        whereHelpertime_Time
	UpdatedAt        whereHelpertime_Time
	DeletedAt        whereHelpernull_Time
	DeviceToken      whereHelperstring
	AwsSNSAppArn     whereHelperstring
	Admin            whereHelperbool
	EmailVerified    whereHelperbool
	Blocked          whereHelperbool
	Feedback         whereHelpernull_String
	LastloginAt      whereHelpernull_Time
	SuperAdmin       whereHelperbool
	DeletedByAdmin   whereHelperbool
	PlaidAccessToken whereHelpernull_String
}{
	ImpartWealthID:   whereHelperstring{field: "`user`.`impart_wealth_id`"},
	AuthenticationID: whereHelperstring{field: "`user`.`authentication_id`"},
	Email:            whereHelperstring{field: "`user`.`email`"},
	ScreenName:       whereHelperstring{field: "`user`.`screen_name`"},
	CreatedAt:        whereHelpertime_Time{field: "`user`.`created_at`"},
	UpdatedAt:        whereHelpertime_Time{field: "`user`.`updated_at`"},
	DeletedAt:        whereHelpernull_Time{field: "`user`.`deleted_at`"},
	DeviceToken:      whereHelperstring{field: "`user`.`device_token`"},
	AwsSNSAppArn:     whereHelperstring{field: "`user`.`aws_sns_app_arn`"},
	Admin:            whereHelperbool{field: "`user`.`admin`"},
	EmailVerified:    whereHelperbool{field: "`user`.`email_verified`"},
	Blocked:          whereHelperbool{field: "`user`.`blocked`"},
	Feedback:         whereHelpernull_String{field: "`user`.`feedback`"},
	LastloginAt:      whereHelpernull_Time{field: "`user`.`lastlogin_at`"},
	SuperAdmin:       whereHelperbool{field: "`user`.`super_admin`"},
	DeletedByAdmin:   whereHelperbool{field: "`user`.`deleted_by_admin`"},
	PlaidAccessToken: whereHelpernull_String{field: "`user`.`plaid_access_token`"},
}

// UserRels is where relationship names are stored.
var UserRels = struct {
	ImpartWealthProfile                    string
	ImpartWealthComments                   string
	ImpartWealthCommentEdits               string
	ImpartWealthCommentReactions           string
	AdminHiveHives                         string
	MemberHiveHives                        string
	ImpartWealthNotificationDeviceMappings string
	ImpartWealthPosts                      string
	ImpartWealthPostEdits                  string
	ImpartWealthPostReactions              string
	ImpartWealthUserAnswers                string
	ImpartWealthUserConfigurations         string
	ImpartWealthUserDevices                string
}{
	ImpartWealthProfile:                    "ImpartWealthProfile",
	ImpartWealthComments:                   "ImpartWealthComments",
	ImpartWealthCommentEdits:               "ImpartWealthCommentEdits",
	ImpartWealthCommentReactions:           "ImpartWealthCommentReactions",
	AdminHiveHives:                         "AdminHiveHives",
	MemberHiveHives:                        "MemberHiveHives",
	ImpartWealthNotificationDeviceMappings: "ImpartWealthNotificationDeviceMappings",
	ImpartWealthPosts:                      "ImpartWealthPosts",
	ImpartWealthPostEdits:                  "ImpartWealthPostEdits",
	ImpartWealthPostReactions:              "ImpartWealthPostReactions",
	ImpartWealthUserAnswers:                "ImpartWealthUserAnswers",
	ImpartWealthUserConfigurations:         "ImpartWealthUserConfigurations",
	ImpartWealthUserDevices:                "ImpartWealthUserDevices",
}

// userR is where relationships are stored.
type userR struct {
	ImpartWealthProfile                    *Profile                       `boil:"ImpartWealthProfile" json:"ImpartWealthProfile" toml:"ImpartWealthProfile" yaml:"ImpartWealthProfile"`
	ImpartWealthComments                   CommentSlice                   `boil:"ImpartWealthComments" json:"ImpartWealthComments" toml:"ImpartWealthComments" yaml:"ImpartWealthComments"`
	ImpartWealthCommentEdits               CommentEditSlice               `boil:"ImpartWealthCommentEdits" json:"ImpartWealthCommentEdits" toml:"ImpartWealthCommentEdits" yaml:"ImpartWealthCommentEdits"`
	ImpartWealthCommentReactions           CommentReactionSlice           `boil:"ImpartWealthCommentReactions" json:"ImpartWealthCommentReactions" toml:"ImpartWealthCommentReactions" yaml:"ImpartWealthCommentReactions"`
	AdminHiveHives                         HiveSlice                      `boil:"AdminHiveHives" json:"AdminHiveHives" toml:"AdminHiveHives" yaml:"AdminHiveHives"`
	MemberHiveHives                        HiveSlice                      `boil:"MemberHiveHives" json:"MemberHiveHives" toml:"MemberHiveHives" yaml:"MemberHiveHives"`
	ImpartWealthNotificationDeviceMappings NotificationDeviceMappingSlice `boil:"ImpartWealthNotificationDeviceMappings" json:"ImpartWealthNotificationDeviceMappings" toml:"ImpartWealthNotificationDeviceMappings" yaml:"ImpartWealthNotificationDeviceMappings"`
	ImpartWealthPosts                      PostSlice                      `boil:"ImpartWealthPosts" json:"ImpartWealthPosts" toml:"ImpartWealthPosts" yaml:"ImpartWealthPosts"`
	ImpartWealthPostEdits                  PostEditSlice                  `boil:"ImpartWealthPostEdits" json:"ImpartWealthPostEdits" toml:"ImpartWealthPostEdits" yaml:"ImpartWealthPostEdits"`
	ImpartWealthPostReactions              PostReactionSlice              `boil:"ImpartWealthPostReactions" json:"ImpartWealthPostReactions" toml:"ImpartWealthPostReactions" yaml:"ImpartWealthPostReactions"`
	ImpartWealthUserAnswers                UserAnswerSlice                `boil:"ImpartWealthUserAnswers" json:"ImpartWealthUserAnswers" toml:"ImpartWealthUserAnswers" yaml:"ImpartWealthUserAnswers"`
	ImpartWealthUserConfigurations         UserConfigurationSlice         `boil:"ImpartWealthUserConfigurations" json:"ImpartWealthUserConfigurations" toml:"ImpartWealthUserConfigurations" yaml:"ImpartWealthUserConfigurations"`
	ImpartWealthUserDevices                UserDeviceSlice                `boil:"ImpartWealthUserDevices" json:"ImpartWealthUserDevices" toml:"ImpartWealthUserDevices" yaml:"ImpartWealthUserDevices"`
}

// NewStruct creates a new relationship struct
func (*userR) NewStruct() *userR {
	return &userR{}
}

// userL is where Load methods for each relationship are stored.
type userL struct{}

var (
	userAllColumns            = []string{"impart_wealth_id", "authentication_id", "email", "screen_name", "created_at", "updated_at", "deleted_at", "device_token", "aws_sns_app_arn", "admin", "email_verified", "blocked", "feedback", "lastlogin_at", "super_admin", "deleted_by_admin", "plaid_access_token"}
	userColumnsWithoutDefault = []string{"impart_wealth_id", "authentication_id", "email", "screen_name", "created_at", "updated_at", "deleted_at", "device_token", "aws_sns_app_arn", "admin", "email_verified", "feedback", "lastlogin_at", "plaid_access_token"}
	userColumnsWithDefault    = []string{"blocked", "super_admin", "deleted_by_admin"}
	userPrimaryKeyColumns     = []string{"impart_wealth_id"}
)

type (
	// UserSlice is an alias for a slice of pointers to User.
	// This should almost always be used instead of []User.
	UserSlice []*User
	// UserHook is the signature for custom User hook methods
	UserHook func(context.Context, boil.ContextExecutor, *User) error

	userQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	userType                 = reflect.TypeOf(&User{})
	userMapping              = queries.MakeStructMapping(userType)
	userPrimaryKeyMapping, _ = queries.BindMapping(userType, userMapping, userPrimaryKeyColumns)
	userInsertCacheMut       sync.RWMutex
	userInsertCache          = make(map[string]insertCache)
	userUpdateCacheMut       sync.RWMutex
	userUpdateCache          = make(map[string]updateCache)
	userUpsertCacheMut       sync.RWMutex
	userUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var userBeforeInsertHooks []UserHook
var userBeforeUpdateHooks []UserHook
var userBeforeDeleteHooks []UserHook
var userBeforeUpsertHooks []UserHook

var userAfterInsertHooks []UserHook
var userAfterSelectHooks []UserHook
var userAfterUpdateHooks []UserHook
var userAfterDeleteHooks []UserHook
var userAfterUpsertHooks []UserHook

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *User) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range userBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *User) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range userBeforeUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *User) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range userBeforeDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *User) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range userBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *User) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range userAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterSelectHooks executes all "after Select" hooks.
func (o *User) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range userAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *User) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range userAfterUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *User) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range userAfterDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *User) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range userAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddUserHook registers your hook function for all future operations.
func AddUserHook(hookPoint boil.HookPoint, userHook UserHook) {
	switch hookPoint {
	case boil.BeforeInsertHook:
		userBeforeInsertHooks = append(userBeforeInsertHooks, userHook)
	case boil.BeforeUpdateHook:
		userBeforeUpdateHooks = append(userBeforeUpdateHooks, userHook)
	case boil.BeforeDeleteHook:
		userBeforeDeleteHooks = append(userBeforeDeleteHooks, userHook)
	case boil.BeforeUpsertHook:
		userBeforeUpsertHooks = append(userBeforeUpsertHooks, userHook)
	case boil.AfterInsertHook:
		userAfterInsertHooks = append(userAfterInsertHooks, userHook)
	case boil.AfterSelectHook:
		userAfterSelectHooks = append(userAfterSelectHooks, userHook)
	case boil.AfterUpdateHook:
		userAfterUpdateHooks = append(userAfterUpdateHooks, userHook)
	case boil.AfterDeleteHook:
		userAfterDeleteHooks = append(userAfterDeleteHooks, userHook)
	case boil.AfterUpsertHook:
		userAfterUpsertHooks = append(userAfterUpsertHooks, userHook)
	}
}

// One returns a single user record from the query.
func (q userQuery) One(ctx context.Context, exec boil.ContextExecutor) (*User, error) {
	o := &User{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "dbmodels: failed to execute a one query for user")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all User records from the query.
func (q userQuery) All(ctx context.Context, exec boil.ContextExecutor) (UserSlice, error) {
	var o []*User

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "dbmodels: failed to assign all query results to User slice")
	}

	if len(userAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all User records in the query.
func (q userQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: failed to count user rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q userQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "dbmodels: failed to check if user exists")
	}

	return count > 0, nil
}

// ImpartWealthProfile pointed to by the foreign key.
func (o *User) ImpartWealthProfile(mods ...qm.QueryMod) profileQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`impart_wealth_id` = ?", o.ImpartWealthID),
	}

	queryMods = append(queryMods, mods...)

	query := Profiles(queryMods...)
	queries.SetFrom(query.Query, "`profile`")

	return query
}

// ImpartWealthComments retrieves all the comment's Comments with an executor via impart_wealth_id column.
func (o *User) ImpartWealthComments(mods ...qm.QueryMod) commentQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`comment`.`impart_wealth_id`=?", o.ImpartWealthID),
		qmhelper.WhereIsNull("`comment`.`deleted_at`"),
	)

	query := Comments(queryMods...)
	queries.SetFrom(query.Query, "`comment`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`comment`.*"})
	}

	return query
}

// ImpartWealthCommentEdits retrieves all the comment_edit's CommentEdits with an executor via impart_wealth_id column.
func (o *User) ImpartWealthCommentEdits(mods ...qm.QueryMod) commentEditQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`comment_edits`.`impart_wealth_id`=?", o.ImpartWealthID),
		qmhelper.WhereIsNull("`comment_edits`.`deleted_at`"),
	)

	query := CommentEdits(queryMods...)
	queries.SetFrom(query.Query, "`comment_edits`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`comment_edits`.*"})
	}

	return query
}

// ImpartWealthCommentReactions retrieves all the comment_reaction's CommentReactions with an executor via impart_wealth_id column.
func (o *User) ImpartWealthCommentReactions(mods ...qm.QueryMod) commentReactionQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`comment_reactions`.`impart_wealth_id`=?", o.ImpartWealthID),
		qmhelper.WhereIsNull("`comment_reactions`.`deleted_at`"),
	)

	query := CommentReactions(queryMods...)
	queries.SetFrom(query.Query, "`comment_reactions`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`comment_reactions`.*"})
	}

	return query
}

// AdminHiveHives retrieves all the hive's Hives with an executor via hive_id column.
func (o *User) AdminHiveHives(mods ...qm.QueryMod) hiveQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.InnerJoin("`hive_admins` on `hive`.`hive_id` = `hive_admins`.`admin_hive_id`"),
		qm.Where("`hive_admins`.`admin_impart_wealth_id`=?", o.ImpartWealthID),
	)

	query := Hives(queryMods...)
	queries.SetFrom(query.Query, "`hive`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`hive`.*"})
	}

	return query
}

// MemberHiveHives retrieves all the hive's Hives with an executor via hive_id column.
func (o *User) MemberHiveHives(mods ...qm.QueryMod) hiveQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.InnerJoin("`hive_members` on `hive`.`hive_id` = `hive_members`.`member_hive_id`"),
		qm.Where("`hive_members`.`member_impart_wealth_id`=?", o.ImpartWealthID),
	)

	query := Hives(queryMods...)
	queries.SetFrom(query.Query, "`hive`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`hive`.*"})
	}

	return query
}

// ImpartWealthNotificationDeviceMappings retrieves all the notification_device_mapping's NotificationDeviceMappings with an executor via impart_wealth_id column.
func (o *User) ImpartWealthNotificationDeviceMappings(mods ...qm.QueryMod) notificationDeviceMappingQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`notification_device_mapping`.`impart_wealth_id`=?", o.ImpartWealthID),
	)

	query := NotificationDeviceMappings(queryMods...)
	queries.SetFrom(query.Query, "`notification_device_mapping`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`notification_device_mapping`.*"})
	}

	return query
}

// ImpartWealthPosts retrieves all the post's Posts with an executor via impart_wealth_id column.
func (o *User) ImpartWealthPosts(mods ...qm.QueryMod) postQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`post`.`impart_wealth_id`=?", o.ImpartWealthID),
		qmhelper.WhereIsNull("`post`.`deleted_at`"),
	)

	query := Posts(queryMods...)
	queries.SetFrom(query.Query, "`post`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`post`.*"})
	}

	return query
}

// ImpartWealthPostEdits retrieves all the post_edit's PostEdits with an executor via impart_wealth_id column.
func (o *User) ImpartWealthPostEdits(mods ...qm.QueryMod) postEditQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`post_edits`.`impart_wealth_id`=?", o.ImpartWealthID),
		qmhelper.WhereIsNull("`post_edits`.`deleted_at`"),
	)

	query := PostEdits(queryMods...)
	queries.SetFrom(query.Query, "`post_edits`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`post_edits`.*"})
	}

	return query
}

// ImpartWealthPostReactions retrieves all the post_reaction's PostReactions with an executor via impart_wealth_id column.
func (o *User) ImpartWealthPostReactions(mods ...qm.QueryMod) postReactionQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`post_reactions`.`impart_wealth_id`=?", o.ImpartWealthID),
		qmhelper.WhereIsNull("`post_reactions`.`deleted_at`"),
	)

	query := PostReactions(queryMods...)
	queries.SetFrom(query.Query, "`post_reactions`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`post_reactions`.*"})
	}

	return query
}

// ImpartWealthUserAnswers retrieves all the user_answer's UserAnswers with an executor via impart_wealth_id column.
func (o *User) ImpartWealthUserAnswers(mods ...qm.QueryMod) userAnswerQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`user_answers`.`impart_wealth_id`=?", o.ImpartWealthID),
		qmhelper.WhereIsNull("`user_answers`.`deleted_at`"),
	)

	query := UserAnswers(queryMods...)
	queries.SetFrom(query.Query, "`user_answers`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`user_answers`.*"})
	}

	return query
}

// ImpartWealthUserConfigurations retrieves all the user_configuration's UserConfigurations with an executor via impart_wealth_id column.
func (o *User) ImpartWealthUserConfigurations(mods ...qm.QueryMod) userConfigurationQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`user_configurations`.`impart_wealth_id`=?", o.ImpartWealthID),
	)

	query := UserConfigurations(queryMods...)
	queries.SetFrom(query.Query, "`user_configurations`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`user_configurations`.*"})
	}

	return query
}

// ImpartWealthUserDevices retrieves all the user_device's UserDevices with an executor via impart_wealth_id column.
func (o *User) ImpartWealthUserDevices(mods ...qm.QueryMod) userDeviceQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`user_devices`.`impart_wealth_id`=?", o.ImpartWealthID),
		qmhelper.WhereIsNull("`user_devices`.`deleted_at`"),
	)

	query := UserDevices(queryMods...)
	queries.SetFrom(query.Query, "`user_devices`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`user_devices`.*"})
	}

	return query
}

// LoadImpartWealthProfile allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-1 relationship.
func (userL) LoadImpartWealthProfile(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		object = maybeUser.(*User)
	} else {
		slice = *maybeUser.(*[]*User)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		args = append(args, object.ImpartWealthID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}

			for _, a := range args {
				if a == obj.ImpartWealthID {
					continue Outer
				}
			}

			args = append(args, obj.ImpartWealthID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`profile`),
		qm.WhereIn(`profile.impart_wealth_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Profile")
	}

	var resultSlice []*Profile
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Profile")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for profile")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for profile")
	}

	if len(userAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.ImpartWealthProfile = foreign
		if foreign.R == nil {
			foreign.R = &profileR{}
		}
		foreign.R.ImpartWealth = object
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.ImpartWealthID == foreign.ImpartWealthID {
				local.R.ImpartWealthProfile = foreign
				if foreign.R == nil {
					foreign.R = &profileR{}
				}
				foreign.R.ImpartWealth = local
				break
			}
		}
	}

	return nil
}

// LoadImpartWealthComments allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userL) LoadImpartWealthComments(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		object = maybeUser.(*User)
	} else {
		slice = *maybeUser.(*[]*User)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		args = append(args, object.ImpartWealthID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}

			for _, a := range args {
				if a == obj.ImpartWealthID {
					continue Outer
				}
			}

			args = append(args, obj.ImpartWealthID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`comment`),
		qm.WhereIn(`comment.impart_wealth_id in ?`, args...),
		qmhelper.WhereIsNull(`comment.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load comment")
	}

	var resultSlice []*Comment
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice comment")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on comment")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for comment")
	}

	if len(commentAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.ImpartWealthComments = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &commentR{}
			}
			foreign.R.ImpartWealth = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ImpartWealthID == foreign.ImpartWealthID {
				local.R.ImpartWealthComments = append(local.R.ImpartWealthComments, foreign)
				if foreign.R == nil {
					foreign.R = &commentR{}
				}
				foreign.R.ImpartWealth = local
				break
			}
		}
	}

	return nil
}

// LoadImpartWealthCommentEdits allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userL) LoadImpartWealthCommentEdits(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		object = maybeUser.(*User)
	} else {
		slice = *maybeUser.(*[]*User)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		args = append(args, object.ImpartWealthID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}

			for _, a := range args {
				if a == obj.ImpartWealthID {
					continue Outer
				}
			}

			args = append(args, obj.ImpartWealthID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`comment_edits`),
		qm.WhereIn(`comment_edits.impart_wealth_id in ?`, args...),
		qmhelper.WhereIsNull(`comment_edits.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load comment_edits")
	}

	var resultSlice []*CommentEdit
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice comment_edits")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on comment_edits")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for comment_edits")
	}

	if len(commentEditAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.ImpartWealthCommentEdits = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &commentEditR{}
			}
			foreign.R.ImpartWealth = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ImpartWealthID == foreign.ImpartWealthID {
				local.R.ImpartWealthCommentEdits = append(local.R.ImpartWealthCommentEdits, foreign)
				if foreign.R == nil {
					foreign.R = &commentEditR{}
				}
				foreign.R.ImpartWealth = local
				break
			}
		}
	}

	return nil
}

// LoadImpartWealthCommentReactions allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userL) LoadImpartWealthCommentReactions(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		object = maybeUser.(*User)
	} else {
		slice = *maybeUser.(*[]*User)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		args = append(args, object.ImpartWealthID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}

			for _, a := range args {
				if a == obj.ImpartWealthID {
					continue Outer
				}
			}

			args = append(args, obj.ImpartWealthID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`comment_reactions`),
		qm.WhereIn(`comment_reactions.impart_wealth_id in ?`, args...),
		qmhelper.WhereIsNull(`comment_reactions.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load comment_reactions")
	}

	var resultSlice []*CommentReaction
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice comment_reactions")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on comment_reactions")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for comment_reactions")
	}

	if len(commentReactionAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.ImpartWealthCommentReactions = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &commentReactionR{}
			}
			foreign.R.ImpartWealth = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ImpartWealthID == foreign.ImpartWealthID {
				local.R.ImpartWealthCommentReactions = append(local.R.ImpartWealthCommentReactions, foreign)
				if foreign.R == nil {
					foreign.R = &commentReactionR{}
				}
				foreign.R.ImpartWealth = local
				break
			}
		}
	}

	return nil
}

// LoadAdminHiveHives allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userL) LoadAdminHiveHives(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		object = maybeUser.(*User)
	} else {
		slice = *maybeUser.(*[]*User)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		args = append(args, object.ImpartWealthID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}

			for _, a := range args {
				if a == obj.ImpartWealthID {
					continue Outer
				}
			}

			args = append(args, obj.ImpartWealthID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.Select("`hive`.hive_id, `hive`.name, `hive`.description, `hive`.pinned_post_id, `hive`.tag_comparisons, `hive`.notification_topic_arn, `hive`.hive_distributions, `hive`.created_at, `hive`.deleted_at, `a`.`admin_impart_wealth_id`"),
		qm.From("`hive`"),
		qm.InnerJoin("`hive_admins` as `a` on `hive`.`hive_id` = `a`.`admin_hive_id`"),
		qm.WhereIn("`a`.`admin_impart_wealth_id` in ?", args...),
		qmhelper.WhereIsNull("`hive`.`deleted_at`"),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load hive")
	}

	var resultSlice []*Hive

	var localJoinCols []string
	for results.Next() {
		one := new(Hive)
		var localJoinCol string

		err = results.Scan(&one.HiveID, &one.Name, &one.Description, &one.PinnedPostID, &one.TagComparisons, &one.NotificationTopicArn, &one.HiveDistributions, &one.CreatedAt, &one.DeletedAt, &localJoinCol)
		if err != nil {
			return errors.Wrap(err, "failed to scan eager loaded results for hive")
		}
		if err = results.Err(); err != nil {
			return errors.Wrap(err, "failed to plebian-bind eager loaded slice hive")
		}

		resultSlice = append(resultSlice, one)
		localJoinCols = append(localJoinCols, localJoinCol)
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on hive")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for hive")
	}

	if len(hiveAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.AdminHiveHives = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &hiveR{}
			}
			foreign.R.AdminImpartWealthUsers = append(foreign.R.AdminImpartWealthUsers, object)
		}
		return nil
	}

	for i, foreign := range resultSlice {
		localJoinCol := localJoinCols[i]
		for _, local := range slice {
			if local.ImpartWealthID == localJoinCol {
				local.R.AdminHiveHives = append(local.R.AdminHiveHives, foreign)
				if foreign.R == nil {
					foreign.R = &hiveR{}
				}
				foreign.R.AdminImpartWealthUsers = append(foreign.R.AdminImpartWealthUsers, local)
				break
			}
		}
	}

	return nil
}

// LoadMemberHiveHives allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userL) LoadMemberHiveHives(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		object = maybeUser.(*User)
	} else {
		slice = *maybeUser.(*[]*User)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		args = append(args, object.ImpartWealthID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}

			for _, a := range args {
				if a == obj.ImpartWealthID {
					continue Outer
				}
			}

			args = append(args, obj.ImpartWealthID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.Select("`hive`.hive_id, `hive`.name, `hive`.description, `hive`.pinned_post_id, `hive`.tag_comparisons, `hive`.notification_topic_arn, `hive`.hive_distributions, `hive`.created_at, `hive`.deleted_at, `a`.`member_impart_wealth_id`"),
		qm.From("`hive`"),
		qm.InnerJoin("`hive_members` as `a` on `hive`.`hive_id` = `a`.`member_hive_id`"),
		qm.WhereIn("`a`.`member_impart_wealth_id` in ?", args...),
		qmhelper.WhereIsNull("`hive`.`deleted_at`"),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load hive")
	}

	var resultSlice []*Hive

	var localJoinCols []string
	for results.Next() {
		one := new(Hive)
		var localJoinCol string

		err = results.Scan(&one.HiveID, &one.Name, &one.Description, &one.PinnedPostID, &one.TagComparisons, &one.NotificationTopicArn, &one.HiveDistributions, &one.CreatedAt, &one.DeletedAt, &localJoinCol)
		if err != nil {
			return errors.Wrap(err, "failed to scan eager loaded results for hive")
		}
		if err = results.Err(); err != nil {
			return errors.Wrap(err, "failed to plebian-bind eager loaded slice hive")
		}

		resultSlice = append(resultSlice, one)
		localJoinCols = append(localJoinCols, localJoinCol)
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on hive")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for hive")
	}

	if len(hiveAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.MemberHiveHives = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &hiveR{}
			}
			foreign.R.MemberImpartWealthUsers = append(foreign.R.MemberImpartWealthUsers, object)
		}
		return nil
	}

	for i, foreign := range resultSlice {
		localJoinCol := localJoinCols[i]
		for _, local := range slice {
			if local.ImpartWealthID == localJoinCol {
				local.R.MemberHiveHives = append(local.R.MemberHiveHives, foreign)
				if foreign.R == nil {
					foreign.R = &hiveR{}
				}
				foreign.R.MemberImpartWealthUsers = append(foreign.R.MemberImpartWealthUsers, local)
				break
			}
		}
	}

	return nil
}

// LoadImpartWealthNotificationDeviceMappings allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userL) LoadImpartWealthNotificationDeviceMappings(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		object = maybeUser.(*User)
	} else {
		slice = *maybeUser.(*[]*User)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		args = append(args, object.ImpartWealthID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}

			for _, a := range args {
				if a == obj.ImpartWealthID {
					continue Outer
				}
			}

			args = append(args, obj.ImpartWealthID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`notification_device_mapping`),
		qm.WhereIn(`notification_device_mapping.impart_wealth_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load notification_device_mapping")
	}

	var resultSlice []*NotificationDeviceMapping
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice notification_device_mapping")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on notification_device_mapping")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for notification_device_mapping")
	}

	if len(notificationDeviceMappingAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.ImpartWealthNotificationDeviceMappings = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &notificationDeviceMappingR{}
			}
			foreign.R.ImpartWealth = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ImpartWealthID == foreign.ImpartWealthID {
				local.R.ImpartWealthNotificationDeviceMappings = append(local.R.ImpartWealthNotificationDeviceMappings, foreign)
				if foreign.R == nil {
					foreign.R = &notificationDeviceMappingR{}
				}
				foreign.R.ImpartWealth = local
				break
			}
		}
	}

	return nil
}

// LoadImpartWealthPosts allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userL) LoadImpartWealthPosts(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		object = maybeUser.(*User)
	} else {
		slice = *maybeUser.(*[]*User)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		args = append(args, object.ImpartWealthID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}

			for _, a := range args {
				if a == obj.ImpartWealthID {
					continue Outer
				}
			}

			args = append(args, obj.ImpartWealthID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`post`),
		qm.WhereIn(`post.impart_wealth_id in ?`, args...),
		qmhelper.WhereIsNull(`post.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load post")
	}

	var resultSlice []*Post
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice post")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on post")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for post")
	}

	if len(postAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.ImpartWealthPosts = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &postR{}
			}
			foreign.R.ImpartWealth = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ImpartWealthID == foreign.ImpartWealthID {
				local.R.ImpartWealthPosts = append(local.R.ImpartWealthPosts, foreign)
				if foreign.R == nil {
					foreign.R = &postR{}
				}
				foreign.R.ImpartWealth = local
				break
			}
		}
	}

	return nil
}

// LoadImpartWealthPostEdits allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userL) LoadImpartWealthPostEdits(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		object = maybeUser.(*User)
	} else {
		slice = *maybeUser.(*[]*User)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		args = append(args, object.ImpartWealthID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}

			for _, a := range args {
				if a == obj.ImpartWealthID {
					continue Outer
				}
			}

			args = append(args, obj.ImpartWealthID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`post_edits`),
		qm.WhereIn(`post_edits.impart_wealth_id in ?`, args...),
		qmhelper.WhereIsNull(`post_edits.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load post_edits")
	}

	var resultSlice []*PostEdit
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice post_edits")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on post_edits")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for post_edits")
	}

	if len(postEditAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.ImpartWealthPostEdits = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &postEditR{}
			}
			foreign.R.ImpartWealth = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ImpartWealthID == foreign.ImpartWealthID {
				local.R.ImpartWealthPostEdits = append(local.R.ImpartWealthPostEdits, foreign)
				if foreign.R == nil {
					foreign.R = &postEditR{}
				}
				foreign.R.ImpartWealth = local
				break
			}
		}
	}

	return nil
}

// LoadImpartWealthPostReactions allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userL) LoadImpartWealthPostReactions(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		object = maybeUser.(*User)
	} else {
		slice = *maybeUser.(*[]*User)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		args = append(args, object.ImpartWealthID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}

			for _, a := range args {
				if a == obj.ImpartWealthID {
					continue Outer
				}
			}

			args = append(args, obj.ImpartWealthID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`post_reactions`),
		qm.WhereIn(`post_reactions.impart_wealth_id in ?`, args...),
		qmhelper.WhereIsNull(`post_reactions.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load post_reactions")
	}

	var resultSlice []*PostReaction
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice post_reactions")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on post_reactions")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for post_reactions")
	}

	if len(postReactionAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.ImpartWealthPostReactions = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &postReactionR{}
			}
			foreign.R.ImpartWealth = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ImpartWealthID == foreign.ImpartWealthID {
				local.R.ImpartWealthPostReactions = append(local.R.ImpartWealthPostReactions, foreign)
				if foreign.R == nil {
					foreign.R = &postReactionR{}
				}
				foreign.R.ImpartWealth = local
				break
			}
		}
	}

	return nil
}

// LoadImpartWealthUserAnswers allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userL) LoadImpartWealthUserAnswers(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		object = maybeUser.(*User)
	} else {
		slice = *maybeUser.(*[]*User)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		args = append(args, object.ImpartWealthID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}

			for _, a := range args {
				if a == obj.ImpartWealthID {
					continue Outer
				}
			}

			args = append(args, obj.ImpartWealthID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`user_answers`),
		qm.WhereIn(`user_answers.impart_wealth_id in ?`, args...),
		qmhelper.WhereIsNull(`user_answers.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load user_answers")
	}

	var resultSlice []*UserAnswer
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice user_answers")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on user_answers")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for user_answers")
	}

	if len(userAnswerAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.ImpartWealthUserAnswers = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &userAnswerR{}
			}
			foreign.R.ImpartWealth = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ImpartWealthID == foreign.ImpartWealthID {
				local.R.ImpartWealthUserAnswers = append(local.R.ImpartWealthUserAnswers, foreign)
				if foreign.R == nil {
					foreign.R = &userAnswerR{}
				}
				foreign.R.ImpartWealth = local
				break
			}
		}
	}

	return nil
}

// LoadImpartWealthUserConfigurations allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userL) LoadImpartWealthUserConfigurations(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		object = maybeUser.(*User)
	} else {
		slice = *maybeUser.(*[]*User)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		args = append(args, object.ImpartWealthID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}

			for _, a := range args {
				if a == obj.ImpartWealthID {
					continue Outer
				}
			}

			args = append(args, obj.ImpartWealthID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`user_configurations`),
		qm.WhereIn(`user_configurations.impart_wealth_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load user_configurations")
	}

	var resultSlice []*UserConfiguration
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice user_configurations")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on user_configurations")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for user_configurations")
	}

	if len(userConfigurationAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.ImpartWealthUserConfigurations = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &userConfigurationR{}
			}
			foreign.R.ImpartWealth = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ImpartWealthID == foreign.ImpartWealthID {
				local.R.ImpartWealthUserConfigurations = append(local.R.ImpartWealthUserConfigurations, foreign)
				if foreign.R == nil {
					foreign.R = &userConfigurationR{}
				}
				foreign.R.ImpartWealth = local
				break
			}
		}
	}

	return nil
}

// LoadImpartWealthUserDevices allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userL) LoadImpartWealthUserDevices(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		object = maybeUser.(*User)
	} else {
		slice = *maybeUser.(*[]*User)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		args = append(args, object.ImpartWealthID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}

			for _, a := range args {
				if a == obj.ImpartWealthID {
					continue Outer
				}
			}

			args = append(args, obj.ImpartWealthID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`user_devices`),
		qm.WhereIn(`user_devices.impart_wealth_id in ?`, args...),
		qmhelper.WhereIsNull(`user_devices.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load user_devices")
	}

	var resultSlice []*UserDevice
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice user_devices")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on user_devices")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for user_devices")
	}

	if len(userDeviceAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.ImpartWealthUserDevices = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &userDeviceR{}
			}
			foreign.R.ImpartWealth = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ImpartWealthID == foreign.ImpartWealthID {
				local.R.ImpartWealthUserDevices = append(local.R.ImpartWealthUserDevices, foreign)
				if foreign.R == nil {
					foreign.R = &userDeviceR{}
				}
				foreign.R.ImpartWealth = local
				break
			}
		}
	}

	return nil
}

// SetImpartWealthProfile of the user to the related item.
// Sets o.R.ImpartWealthProfile to related.
// Adds o to related.R.ImpartWealth.
func (o *User) SetImpartWealthProfile(ctx context.Context, exec boil.ContextExecutor, insert bool, related *Profile) error {
	var err error

	if insert {
		related.ImpartWealthID = o.ImpartWealthID

		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	} else {
		updateQuery := fmt.Sprintf(
			"UPDATE `profile` SET %s WHERE %s",
			strmangle.SetParamNames("`", "`", 0, []string{"impart_wealth_id"}),
			strmangle.WhereClause("`", "`", 0, profilePrimaryKeyColumns),
		)
		values := []interface{}{o.ImpartWealthID, related.ImpartWealthID}

		if boil.IsDebug(ctx) {
			writer := boil.DebugWriterFrom(ctx)
			fmt.Fprintln(writer, updateQuery)
			fmt.Fprintln(writer, values)
		}
		if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
			return errors.Wrap(err, "failed to update foreign table")
		}

		related.ImpartWealthID = o.ImpartWealthID

	}

	if o.R == nil {
		o.R = &userR{
			ImpartWealthProfile: related,
		}
	} else {
		o.R.ImpartWealthProfile = related
	}

	if related.R == nil {
		related.R = &profileR{
			ImpartWealth: o,
		}
	} else {
		related.R.ImpartWealth = o
	}
	return nil
}

// AddImpartWealthComments adds the given related objects to the existing relationships
// of the user, optionally inserting them as new records.
// Appends related to o.R.ImpartWealthComments.
// Sets related.R.ImpartWealth appropriately.
func (o *User) AddImpartWealthComments(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Comment) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.ImpartWealthID = o.ImpartWealthID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `comment` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"impart_wealth_id"}),
				strmangle.WhereClause("`", "`", 0, commentPrimaryKeyColumns),
			)
			values := []interface{}{o.ImpartWealthID, rel.CommentID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.ImpartWealthID = o.ImpartWealthID
		}
	}

	if o.R == nil {
		o.R = &userR{
			ImpartWealthComments: related,
		}
	} else {
		o.R.ImpartWealthComments = append(o.R.ImpartWealthComments, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &commentR{
				ImpartWealth: o,
			}
		} else {
			rel.R.ImpartWealth = o
		}
	}
	return nil
}

// AddImpartWealthCommentEdits adds the given related objects to the existing relationships
// of the user, optionally inserting them as new records.
// Appends related to o.R.ImpartWealthCommentEdits.
// Sets related.R.ImpartWealth appropriately.
func (o *User) AddImpartWealthCommentEdits(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*CommentEdit) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.ImpartWealthID = o.ImpartWealthID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `comment_edits` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"impart_wealth_id"}),
				strmangle.WhereClause("`", "`", 0, commentEditPrimaryKeyColumns),
			)
			values := []interface{}{o.ImpartWealthID, rel.CommentID, rel.EditID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.ImpartWealthID = o.ImpartWealthID
		}
	}

	if o.R == nil {
		o.R = &userR{
			ImpartWealthCommentEdits: related,
		}
	} else {
		o.R.ImpartWealthCommentEdits = append(o.R.ImpartWealthCommentEdits, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &commentEditR{
				ImpartWealth: o,
			}
		} else {
			rel.R.ImpartWealth = o
		}
	}
	return nil
}

// AddImpartWealthCommentReactions adds the given related objects to the existing relationships
// of the user, optionally inserting them as new records.
// Appends related to o.R.ImpartWealthCommentReactions.
// Sets related.R.ImpartWealth appropriately.
func (o *User) AddImpartWealthCommentReactions(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*CommentReaction) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.ImpartWealthID = o.ImpartWealthID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `comment_reactions` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"impart_wealth_id"}),
				strmangle.WhereClause("`", "`", 0, commentReactionPrimaryKeyColumns),
			)
			values := []interface{}{o.ImpartWealthID, rel.CommentID, rel.ImpartWealthID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.ImpartWealthID = o.ImpartWealthID
		}
	}

	if o.R == nil {
		o.R = &userR{
			ImpartWealthCommentReactions: related,
		}
	} else {
		o.R.ImpartWealthCommentReactions = append(o.R.ImpartWealthCommentReactions, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &commentReactionR{
				ImpartWealth: o,
			}
		} else {
			rel.R.ImpartWealth = o
		}
	}
	return nil
}

// AddAdminHiveHives adds the given related objects to the existing relationships
// of the user, optionally inserting them as new records.
// Appends related to o.R.AdminHiveHives.
// Sets related.R.AdminImpartWealthUsers appropriately.
func (o *User) AddAdminHiveHives(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Hive) error {
	var err error
	for _, rel := range related {
		if insert {
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		}
	}

	for _, rel := range related {
		query := "insert into `hive_admins` (`admin_impart_wealth_id`, `admin_hive_id`) values (?, ?)"
		values := []interface{}{o.ImpartWealthID, rel.HiveID}

		if boil.IsDebug(ctx) {
			writer := boil.DebugWriterFrom(ctx)
			fmt.Fprintln(writer, query)
			fmt.Fprintln(writer, values)
		}
		_, err = exec.ExecContext(ctx, query, values...)
		if err != nil {
			return errors.Wrap(err, "failed to insert into join table")
		}
	}
	if o.R == nil {
		o.R = &userR{
			AdminHiveHives: related,
		}
	} else {
		o.R.AdminHiveHives = append(o.R.AdminHiveHives, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &hiveR{
				AdminImpartWealthUsers: UserSlice{o},
			}
		} else {
			rel.R.AdminImpartWealthUsers = append(rel.R.AdminImpartWealthUsers, o)
		}
	}
	return nil
}

// SetAdminHiveHives removes all previously related items of the
// user replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.AdminImpartWealthUsers's AdminHiveHives accordingly.
// Replaces o.R.AdminHiveHives with related.
// Sets related.R.AdminImpartWealthUsers's AdminHiveHives accordingly.
func (o *User) SetAdminHiveHives(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Hive) error {
	query := "delete from `hive_admins` where `admin_impart_wealth_id` = ?"
	values := []interface{}{o.ImpartWealthID}
	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
		fmt.Fprintln(writer, values)
	}
	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	removeAdminHiveHivesFromAdminImpartWealthUsersSlice(o, related)
	if o.R != nil {
		o.R.AdminHiveHives = nil
	}
	return o.AddAdminHiveHives(ctx, exec, insert, related...)
}

// RemoveAdminHiveHives relationships from objects passed in.
// Removes related items from R.AdminHiveHives (uses pointer comparison, removal does not keep order)
// Sets related.R.AdminImpartWealthUsers.
func (o *User) RemoveAdminHiveHives(ctx context.Context, exec boil.ContextExecutor, related ...*Hive) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	query := fmt.Sprintf(
		"delete from `hive_admins` where `admin_impart_wealth_id` = ? and `admin_hive_id` in (%s)",
		strmangle.Placeholders(dialect.UseIndexPlaceholders, len(related), 2, 1),
	)
	values := []interface{}{o.ImpartWealthID}
	for _, rel := range related {
		values = append(values, rel.HiveID)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
		fmt.Fprintln(writer, values)
	}
	_, err = exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}
	removeAdminHiveHivesFromAdminImpartWealthUsersSlice(o, related)
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.AdminHiveHives {
			if rel != ri {
				continue
			}

			ln := len(o.R.AdminHiveHives)
			if ln > 1 && i < ln-1 {
				o.R.AdminHiveHives[i] = o.R.AdminHiveHives[ln-1]
			}
			o.R.AdminHiveHives = o.R.AdminHiveHives[:ln-1]
			break
		}
	}

	return nil
}

func removeAdminHiveHivesFromAdminImpartWealthUsersSlice(o *User, related []*Hive) {
	for _, rel := range related {
		if rel.R == nil {
			continue
		}
		for i, ri := range rel.R.AdminImpartWealthUsers {
			if o.ImpartWealthID != ri.ImpartWealthID {
				continue
			}

			ln := len(rel.R.AdminImpartWealthUsers)
			if ln > 1 && i < ln-1 {
				rel.R.AdminImpartWealthUsers[i] = rel.R.AdminImpartWealthUsers[ln-1]
			}
			rel.R.AdminImpartWealthUsers = rel.R.AdminImpartWealthUsers[:ln-1]
			break
		}
	}
}

// AddMemberHiveHives adds the given related objects to the existing relationships
// of the user, optionally inserting them as new records.
// Appends related to o.R.MemberHiveHives.
// Sets related.R.MemberImpartWealthUsers appropriately.
func (o *User) AddMemberHiveHives(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Hive) error {
	var err error
	for _, rel := range related {
		if insert {
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		}
	}

	for _, rel := range related {
		query := "insert into `hive_members` (`member_impart_wealth_id`, `member_hive_id`) values (?, ?)"
		values := []interface{}{o.ImpartWealthID, rel.HiveID}

		if boil.IsDebug(ctx) {
			writer := boil.DebugWriterFrom(ctx)
			fmt.Fprintln(writer, query)
			fmt.Fprintln(writer, values)
		}
		_, err = exec.ExecContext(ctx, query, values...)
		if err != nil {
			return errors.Wrap(err, "failed to insert into join table")
		}
	}
	if o.R == nil {
		o.R = &userR{
			MemberHiveHives: related,
		}
	} else {
		o.R.MemberHiveHives = append(o.R.MemberHiveHives, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &hiveR{
				MemberImpartWealthUsers: UserSlice{o},
			}
		} else {
			rel.R.MemberImpartWealthUsers = append(rel.R.MemberImpartWealthUsers, o)
		}
	}
	return nil
}

// SetMemberHiveHives removes all previously related items of the
// user replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.MemberImpartWealthUsers's MemberHiveHives accordingly.
// Replaces o.R.MemberHiveHives with related.
// Sets related.R.MemberImpartWealthUsers's MemberHiveHives accordingly.
func (o *User) SetMemberHiveHives(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Hive) error {
	query := "delete from `hive_members` where `member_impart_wealth_id` = ?"
	values := []interface{}{o.ImpartWealthID}
	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
		fmt.Fprintln(writer, values)
	}
	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	removeMemberHiveHivesFromMemberImpartWealthUsersSlice(o, related)
	if o.R != nil {
		o.R.MemberHiveHives = nil
	}
	return o.AddMemberHiveHives(ctx, exec, insert, related...)
}

// RemoveMemberHiveHives relationships from objects passed in.
// Removes related items from R.MemberHiveHives (uses pointer comparison, removal does not keep order)
// Sets related.R.MemberImpartWealthUsers.
func (o *User) RemoveMemberHiveHives(ctx context.Context, exec boil.ContextExecutor, related ...*Hive) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	query := fmt.Sprintf(
		"delete from `hive_members` where `member_impart_wealth_id` = ? and `member_hive_id` in (%s)",
		strmangle.Placeholders(dialect.UseIndexPlaceholders, len(related), 2, 1),
	)
	values := []interface{}{o.ImpartWealthID}
	for _, rel := range related {
		values = append(values, rel.HiveID)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
		fmt.Fprintln(writer, values)
	}
	_, err = exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}
	removeMemberHiveHivesFromMemberImpartWealthUsersSlice(o, related)
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.MemberHiveHives {
			if rel != ri {
				continue
			}

			ln := len(o.R.MemberHiveHives)
			if ln > 1 && i < ln-1 {
				o.R.MemberHiveHives[i] = o.R.MemberHiveHives[ln-1]
			}
			o.R.MemberHiveHives = o.R.MemberHiveHives[:ln-1]
			break
		}
	}

	return nil
}

func removeMemberHiveHivesFromMemberImpartWealthUsersSlice(o *User, related []*Hive) {
	for _, rel := range related {
		if rel.R == nil {
			continue
		}
		for i, ri := range rel.R.MemberImpartWealthUsers {
			if o.ImpartWealthID != ri.ImpartWealthID {
				continue
			}

			ln := len(rel.R.MemberImpartWealthUsers)
			if ln > 1 && i < ln-1 {
				rel.R.MemberImpartWealthUsers[i] = rel.R.MemberImpartWealthUsers[ln-1]
			}
			rel.R.MemberImpartWealthUsers = rel.R.MemberImpartWealthUsers[:ln-1]
			break
		}
	}
}

// AddImpartWealthNotificationDeviceMappings adds the given related objects to the existing relationships
// of the user, optionally inserting them as new records.
// Appends related to o.R.ImpartWealthNotificationDeviceMappings.
// Sets related.R.ImpartWealth appropriately.
func (o *User) AddImpartWealthNotificationDeviceMappings(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*NotificationDeviceMapping) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.ImpartWealthID = o.ImpartWealthID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `notification_device_mapping` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"impart_wealth_id"}),
				strmangle.WhereClause("`", "`", 0, notificationDeviceMappingPrimaryKeyColumns),
			)
			values := []interface{}{o.ImpartWealthID, rel.MapID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.ImpartWealthID = o.ImpartWealthID
		}
	}

	if o.R == nil {
		o.R = &userR{
			ImpartWealthNotificationDeviceMappings: related,
		}
	} else {
		o.R.ImpartWealthNotificationDeviceMappings = append(o.R.ImpartWealthNotificationDeviceMappings, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &notificationDeviceMappingR{
				ImpartWealth: o,
			}
		} else {
			rel.R.ImpartWealth = o
		}
	}
	return nil
}

// AddImpartWealthPosts adds the given related objects to the existing relationships
// of the user, optionally inserting them as new records.
// Appends related to o.R.ImpartWealthPosts.
// Sets related.R.ImpartWealth appropriately.
func (o *User) AddImpartWealthPosts(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Post) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.ImpartWealthID = o.ImpartWealthID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `post` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"impart_wealth_id"}),
				strmangle.WhereClause("`", "`", 0, postPrimaryKeyColumns),
			)
			values := []interface{}{o.ImpartWealthID, rel.PostID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.ImpartWealthID = o.ImpartWealthID
		}
	}

	if o.R == nil {
		o.R = &userR{
			ImpartWealthPosts: related,
		}
	} else {
		o.R.ImpartWealthPosts = append(o.R.ImpartWealthPosts, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &postR{
				ImpartWealth: o,
			}
		} else {
			rel.R.ImpartWealth = o
		}
	}
	return nil
}

// AddImpartWealthPostEdits adds the given related objects to the existing relationships
// of the user, optionally inserting them as new records.
// Appends related to o.R.ImpartWealthPostEdits.
// Sets related.R.ImpartWealth appropriately.
func (o *User) AddImpartWealthPostEdits(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*PostEdit) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.ImpartWealthID = o.ImpartWealthID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `post_edits` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"impart_wealth_id"}),
				strmangle.WhereClause("`", "`", 0, postEditPrimaryKeyColumns),
			)
			values := []interface{}{o.ImpartWealthID, rel.PostID, rel.EditID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.ImpartWealthID = o.ImpartWealthID
		}
	}

	if o.R == nil {
		o.R = &userR{
			ImpartWealthPostEdits: related,
		}
	} else {
		o.R.ImpartWealthPostEdits = append(o.R.ImpartWealthPostEdits, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &postEditR{
				ImpartWealth: o,
			}
		} else {
			rel.R.ImpartWealth = o
		}
	}
	return nil
}

// AddImpartWealthPostReactions adds the given related objects to the existing relationships
// of the user, optionally inserting them as new records.
// Appends related to o.R.ImpartWealthPostReactions.
// Sets related.R.ImpartWealth appropriately.
func (o *User) AddImpartWealthPostReactions(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*PostReaction) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.ImpartWealthID = o.ImpartWealthID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `post_reactions` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"impart_wealth_id"}),
				strmangle.WhereClause("`", "`", 0, postReactionPrimaryKeyColumns),
			)
			values := []interface{}{o.ImpartWealthID, rel.PostID, rel.ImpartWealthID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.ImpartWealthID = o.ImpartWealthID
		}
	}

	if o.R == nil {
		o.R = &userR{
			ImpartWealthPostReactions: related,
		}
	} else {
		o.R.ImpartWealthPostReactions = append(o.R.ImpartWealthPostReactions, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &postReactionR{
				ImpartWealth: o,
			}
		} else {
			rel.R.ImpartWealth = o
		}
	}
	return nil
}

// AddImpartWealthUserAnswers adds the given related objects to the existing relationships
// of the user, optionally inserting them as new records.
// Appends related to o.R.ImpartWealthUserAnswers.
// Sets related.R.ImpartWealth appropriately.
func (o *User) AddImpartWealthUserAnswers(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*UserAnswer) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.ImpartWealthID = o.ImpartWealthID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `user_answers` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"impart_wealth_id"}),
				strmangle.WhereClause("`", "`", 0, userAnswerPrimaryKeyColumns),
			)
			values := []interface{}{o.ImpartWealthID, rel.ImpartWealthID, rel.AnswerID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.ImpartWealthID = o.ImpartWealthID
		}
	}

	if o.R == nil {
		o.R = &userR{
			ImpartWealthUserAnswers: related,
		}
	} else {
		o.R.ImpartWealthUserAnswers = append(o.R.ImpartWealthUserAnswers, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &userAnswerR{
				ImpartWealth: o,
			}
		} else {
			rel.R.ImpartWealth = o
		}
	}
	return nil
}

// AddImpartWealthUserConfigurations adds the given related objects to the existing relationships
// of the user, optionally inserting them as new records.
// Appends related to o.R.ImpartWealthUserConfigurations.
// Sets related.R.ImpartWealth appropriately.
func (o *User) AddImpartWealthUserConfigurations(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*UserConfiguration) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.ImpartWealthID = o.ImpartWealthID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `user_configurations` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"impart_wealth_id"}),
				strmangle.WhereClause("`", "`", 0, userConfigurationPrimaryKeyColumns),
			)
			values := []interface{}{o.ImpartWealthID, rel.ConfigID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.ImpartWealthID = o.ImpartWealthID
		}
	}

	if o.R == nil {
		o.R = &userR{
			ImpartWealthUserConfigurations: related,
		}
	} else {
		o.R.ImpartWealthUserConfigurations = append(o.R.ImpartWealthUserConfigurations, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &userConfigurationR{
				ImpartWealth: o,
			}
		} else {
			rel.R.ImpartWealth = o
		}
	}
	return nil
}

// AddImpartWealthUserDevices adds the given related objects to the existing relationships
// of the user, optionally inserting them as new records.
// Appends related to o.R.ImpartWealthUserDevices.
// Sets related.R.ImpartWealth appropriately.
func (o *User) AddImpartWealthUserDevices(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*UserDevice) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.ImpartWealthID = o.ImpartWealthID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `user_devices` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"impart_wealth_id"}),
				strmangle.WhereClause("`", "`", 0, userDevicePrimaryKeyColumns),
			)
			values := []interface{}{o.ImpartWealthID, rel.Token}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.ImpartWealthID = o.ImpartWealthID
		}
	}

	if o.R == nil {
		o.R = &userR{
			ImpartWealthUserDevices: related,
		}
	} else {
		o.R.ImpartWealthUserDevices = append(o.R.ImpartWealthUserDevices, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &userDeviceR{
				ImpartWealth: o,
			}
		} else {
			rel.R.ImpartWealth = o
		}
	}
	return nil
}

// Users retrieves all the records using an executor.
func Users(mods ...qm.QueryMod) userQuery {
	mods = append(mods, qm.From("`user`"), qmhelper.WhereIsNull("`user`.`deleted_at`"))
	return userQuery{NewQuery(mods...)}
}

// FindUser retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindUser(ctx context.Context, exec boil.ContextExecutor, impartWealthID string, selectCols ...string) (*User, error) {
	userObj := &User{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from `user` where `impart_wealth_id`=? and `deleted_at` is null", sel,
	)

	q := queries.Raw(query, impartWealthID)

	err := q.Bind(ctx, exec, userObj)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "dbmodels: unable to select from user")
	}

	if err = userObj.doAfterSelectHooks(ctx, exec); err != nil {
		return userObj, err
	}

	return userObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *User) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("dbmodels: no user provided for insertion")
	}

	var err error
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		if o.CreatedAt.IsZero() {
			o.CreatedAt = currTime
		}
		if o.UpdatedAt.IsZero() {
			o.UpdatedAt = currTime
		}
	}

	if err := o.doBeforeInsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(userColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	userInsertCacheMut.RLock()
	cache, cached := userInsertCache[key]
	userInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			userAllColumns,
			userColumnsWithDefault,
			userColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(userType, userMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(userType, userMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO `user` (`%s`) %%sVALUES (%s)%%s", strings.Join(wl, "`,`"), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO `user` () VALUES ()%s%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			cache.retQuery = fmt.Sprintf("SELECT `%s` FROM `user` WHERE %s", strings.Join(returnColumns, "`,`"), strmangle.WhereClause("`", "`", 0, userPrimaryKeyColumns))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	_, err = exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "dbmodels: unable to insert into user")
	}

	var identifierCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	identifierCols = []interface{}{
		o.ImpartWealthID,
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.retQuery)
		fmt.Fprintln(writer, identifierCols...)
	}
	err = exec.QueryRowContext(ctx, cache.retQuery, identifierCols...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	if err != nil {
		return errors.Wrap(err, "dbmodels: unable to populate default values for user")
	}

CacheNoHooks:
	if !cached {
		userInsertCacheMut.Lock()
		userInsertCache[key] = cache
		userInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(ctx, exec)
}

// Update uses an executor to update the User.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *User) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		o.UpdatedAt = currTime
	}

	var err error
	if err = o.doBeforeUpdateHooks(ctx, exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	userUpdateCacheMut.RLock()
	cache, cached := userUpdateCache[key]
	userUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			userAllColumns,
			userPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("dbmodels: unable to update user, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE `user` SET %s WHERE %s",
			strmangle.SetParamNames("`", "`", 0, wl),
			strmangle.WhereClause("`", "`", 0, userPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(userType, userMapping, append(wl, userPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, values)
	}
	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: unable to update user row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: failed to get rows affected by update for user")
	}

	if !cached {
		userUpdateCacheMut.Lock()
		userUpdateCache[key] = cache
		userUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(ctx, exec)
}

// UpdateAll updates all rows with the specified column values.
func (q userQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: unable to update all for user")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: unable to retrieve rows affected for user")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o UserSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("dbmodels: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), userPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE `user` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, userPrimaryKeyColumns, len(o)))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: unable to update all in user slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: unable to retrieve rows affected all in update all user")
	}
	return rowsAff, nil
}

var mySQLUserUniqueColumns = []string{
	"impart_wealth_id",
	"authentication_id",
	"email",
	"screen_name",
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *User) Upsert(ctx context.Context, exec boil.ContextExecutor, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("dbmodels: no user provided for upsert")
	}
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		if o.CreatedAt.IsZero() {
			o.CreatedAt = currTime
		}
		o.UpdatedAt = currTime
	}

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(userColumnsWithDefault, o)
	nzUniques := queries.NonZeroDefaultSet(mySQLUserUniqueColumns, o)

	if len(nzUniques) == 0 {
		return errors.New("cannot upsert with a table that cannot conflict on a unique column")
	}

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzUniques {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	userUpsertCacheMut.RLock()
	cache, cached := userUpsertCache[key]
	userUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			userAllColumns,
			userColumnsWithDefault,
			userColumnsWithoutDefault,
			nzDefaults,
		)
		update := updateColumns.UpdateColumnSet(
			userAllColumns,
			userPrimaryKeyColumns,
		)

		if !updateColumns.IsNone() && len(update) == 0 {
			return errors.New("dbmodels: unable to upsert user, could not build update column list")
		}

		ret = strmangle.SetComplement(ret, nzUniques)
		cache.query = buildUpsertQueryMySQL(dialect, "`user`", update, insert)
		cache.retQuery = fmt.Sprintf(
			"SELECT %s FROM `user` WHERE %s",
			strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, ret), ","),
			strmangle.WhereClause("`", "`", 0, nzUniques),
		)

		cache.valueMapping, err = queries.BindMapping(userType, userMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(userType, userMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	_, err = exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "dbmodels: unable to upsert for user")
	}

	var uniqueMap []uint64
	var nzUniqueCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	uniqueMap, err = queries.BindMapping(userType, userMapping, nzUniques)
	if err != nil {
		return errors.Wrap(err, "dbmodels: unable to retrieve unique values for user")
	}
	nzUniqueCols = queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), uniqueMap)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.retQuery)
		fmt.Fprintln(writer, nzUniqueCols...)
	}
	err = exec.QueryRowContext(ctx, cache.retQuery, nzUniqueCols...).Scan(returns...)
	if err != nil {
		return errors.Wrap(err, "dbmodels: unable to populate default values for user")
	}

CacheNoHooks:
	if !cached {
		userUpsertCacheMut.Lock()
		userUpsertCache[key] = cache
		userUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}

// Delete deletes a single User record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *User) Delete(ctx context.Context, exec boil.ContextExecutor, hardDelete bool) (int64, error) {
	if o == nil {
		return 0, errors.New("dbmodels: no User provided for delete")
	}

	if err := o.doBeforeDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	var (
		sql  string
		args []interface{}
	)
	if hardDelete {
		args = queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), userPrimaryKeyMapping)
		sql = "DELETE FROM `user` WHERE `impart_wealth_id`=?"
	} else {
		currTime := time.Now().In(boil.GetLocation())
		o.DeletedAt = null.TimeFrom(currTime)
		wl := []string{"deleted_at"}
		sql = fmt.Sprintf("UPDATE `user` SET %s WHERE `impart_wealth_id`=?",
			strmangle.SetParamNames("`", "`", 0, wl),
		)
		valueMapping, err := queries.BindMapping(userType, userMapping, append(wl, userPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
		args = queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), valueMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: unable to delete from user")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: failed to get rows affected by delete for user")
	}

	if err := o.doAfterDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q userQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor, hardDelete bool) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("dbmodels: no userQuery provided for delete all")
	}

	if hardDelete {
		queries.SetDelete(q.Query)
	} else {
		currTime := time.Now().In(boil.GetLocation())
		queries.SetUpdate(q.Query, M{"deleted_at": currTime})
	}

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: unable to delete all from user")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: failed to get rows affected by deleteall for user")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o UserSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor, hardDelete bool) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	if len(userBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	var (
		sql  string
		args []interface{}
	)
	if hardDelete {
		for _, obj := range o {
			pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), userPrimaryKeyMapping)
			args = append(args, pkeyArgs...)
		}
		sql = "DELETE FROM `user` WHERE " +
			strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, userPrimaryKeyColumns, len(o))
	} else {
		currTime := time.Now().In(boil.GetLocation())
		for _, obj := range o {
			pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), userPrimaryKeyMapping)
			args = append(args, pkeyArgs...)
			obj.DeletedAt = null.TimeFrom(currTime)
		}
		wl := []string{"deleted_at"}
		sql = fmt.Sprintf("UPDATE `user` SET %s WHERE "+
			strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, userPrimaryKeyColumns, len(o)),
			strmangle.SetParamNames("`", "`", 0, wl),
		)
		args = append([]interface{}{currTime}, args...)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: unable to delete all from user slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: failed to get rows affected by deleteall for user")
	}

	if len(userAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *User) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindUser(ctx, exec, o.ImpartWealthID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *UserSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := UserSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), userPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT `user`.* FROM `user` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, userPrimaryKeyColumns, len(*o)) +
		"and `deleted_at` is null"

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "dbmodels: unable to reload all in UserSlice")
	}

	*o = slice

	return nil
}

// UserExists checks if the User row exists.
func UserExists(ctx context.Context, exec boil.ContextExecutor, impartWealthID string) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from `user` where `impart_wealth_id`=? and `deleted_at` is null limit 1)"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, impartWealthID)
	}
	row := exec.QueryRowContext(ctx, sql, impartWealthID)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "dbmodels: unable to check if user exists")
	}

	return exists, nil
}
