// Code generated by counterfeiter. DO NOT EDIT.
package hivefakes

import (
	"context"
	"sync"
	"time"

	data "github.com/impartwealthapp/backend/pkg/data/hive"
	"github.com/impartwealthapp/backend/pkg/models"
	"github.com/impartwealthapp/backend/pkg/models/dbmodels"
)

type FakeHiveService struct {
	AddDownVoteStub        func(context.Context, data.ContentInput) error
	addDownVoteMutex       sync.RWMutex
	addDownVoteArgsForCall []struct {
		arg1 context.Context
		arg2 data.ContentInput
	}
	addDownVoteReturns struct {
		result1 error
	}
	addDownVoteReturnsOnCall map[int]struct {
		result1 error
	}
	AddUpVoteStub        func(context.Context, data.ContentInput) error
	addUpVoteMutex       sync.RWMutex
	addUpVoteArgsForCall []struct {
		arg1 context.Context
		arg2 data.ContentInput
	}
	addUpVoteReturns struct {
		result1 error
	}
	addUpVoteReturnsOnCall map[int]struct {
		result1 error
	}
	DeleteCommentStub        func(context.Context, uint64) error
	deleteCommentMutex       sync.RWMutex
	deleteCommentArgsForCall []struct {
		arg1 context.Context
		arg2 uint64
	}
	deleteCommentReturns struct {
		result1 error
	}
	deleteCommentReturnsOnCall map[int]struct {
		result1 error
	}
	DeletePostStub        func(context.Context, uint64) error
	deletePostMutex       sync.RWMutex
	deletePostArgsForCall []struct {
		arg1 context.Context
		arg2 uint64
	}
	deletePostReturns struct {
		result1 error
	}
	deletePostReturnsOnCall map[int]struct {
		result1 error
	}
	EditCommentStub        func(context.Context, *dbmodels.Comment) (*dbmodels.Comment, error)
	editCommentMutex       sync.RWMutex
	editCommentArgsForCall []struct {
		arg1 context.Context
		arg2 *dbmodels.Comment
	}
	editCommentReturns struct {
		result1 *dbmodels.Comment
		result2 error
	}
	editCommentReturnsOnCall map[int]struct {
		result1 *dbmodels.Comment
		result2 error
	}
	EditHiveStub        func(context.Context, *dbmodels.Hive) (*dbmodels.Hive, error)
	editHiveMutex       sync.RWMutex
	editHiveArgsForCall []struct {
		arg1 context.Context
		arg2 *dbmodels.Hive
	}
	editHiveReturns struct {
		result1 *dbmodels.Hive
		result2 error
	}
	editHiveReturnsOnCall map[int]struct {
		result1 *dbmodels.Hive
		result2 error
	}
	EditPostStub        func(context.Context, *dbmodels.Post, dbmodels.TagSlice) (*dbmodels.Post, error)
	editPostMutex       sync.RWMutex
	editPostArgsForCall []struct {
		arg1 context.Context
		arg2 *dbmodels.Post
		arg3 dbmodels.TagSlice
	}
	editPostReturns struct {
		result1 *dbmodels.Post
		result2 error
	}
	editPostReturnsOnCall map[int]struct {
		result1 *dbmodels.Post
		result2 error
	}
	GetCommentStub        func(context.Context, uint64) (*dbmodels.Comment, error)
	getCommentMutex       sync.RWMutex
	getCommentArgsForCall []struct {
		arg1 context.Context
		arg2 uint64
	}
	getCommentReturns struct {
		result1 *dbmodels.Comment
		result2 error
	}
	getCommentReturnsOnCall map[int]struct {
		result1 *dbmodels.Comment
		result2 error
	}
	GetCommentsStub        func(context.Context, uint64, int, int) (dbmodels.CommentSlice, *models.NextPage, error)
	getCommentsMutex       sync.RWMutex
	getCommentsArgsForCall []struct {
		arg1 context.Context
		arg2 uint64
		arg3 int
		arg4 int
	}
	getCommentsReturns struct {
		result1 dbmodels.CommentSlice
		result2 *models.NextPage
		result3 error
	}
	getCommentsReturnsOnCall map[int]struct {
		result1 dbmodels.CommentSlice
		result2 *models.NextPage
		result3 error
	}
	GetHiveStub        func(context.Context, uint64) (*dbmodels.Hive, error)
	getHiveMutex       sync.RWMutex
	getHiveArgsForCall []struct {
		arg1 context.Context
		arg2 uint64
	}
	getHiveReturns struct {
		result1 *dbmodels.Hive
		result2 error
	}
	getHiveReturnsOnCall map[int]struct {
		result1 *dbmodels.Hive
		result2 error
	}
	GetHivesStub        func(context.Context) (dbmodels.HiveSlice, error)
	getHivesMutex       sync.RWMutex
	getHivesArgsForCall []struct {
		arg1 context.Context
	}
	getHivesReturns struct {
		result1 dbmodels.HiveSlice
		result2 error
	}
	getHivesReturnsOnCall map[int]struct {
		result1 dbmodels.HiveSlice
		result2 error
	}
	GetPostStub        func(context.Context, uint64) (*dbmodels.Post, error)
	getPostMutex       sync.RWMutex
	getPostArgsForCall []struct {
		arg1 context.Context
		arg2 uint64
	}
	getPostReturns struct {
		result1 *dbmodels.Post
		result2 error
	}
	getPostReturnsOnCall map[int]struct {
		result1 *dbmodels.Post
		result2 error
	}
	GetPostsStub        func(context.Context, data.GetPostsInput) (dbmodels.PostSlice, *models.NextPage, error)
	getPostsMutex       sync.RWMutex
	getPostsArgsForCall []struct {
		arg1 context.Context
		arg2 data.GetPostsInput
	}
	getPostsReturns struct {
		result1 dbmodels.PostSlice
		result2 *models.NextPage
		result3 error
	}
	getPostsReturnsOnCall map[int]struct {
		result1 dbmodels.PostSlice
		result2 *models.NextPage
		result3 error
	}
	GetPostsWithReviewedCommentsStub        func(context.Context, uint64, time.Time, int) (dbmodels.PostSlice, models.NextPage, error)
	getPostsWithReviewedCommentsMutex       sync.RWMutex
	getPostsWithReviewedCommentsArgsForCall []struct {
		arg1 context.Context
		arg2 uint64
		arg3 time.Time
		arg4 int
	}
	getPostsWithReviewedCommentsReturns struct {
		result1 dbmodels.PostSlice
		result2 models.NextPage
		result3 error
	}
	getPostsWithReviewedCommentsReturnsOnCall map[int]struct {
		result1 dbmodels.PostSlice
		result2 models.NextPage
		result3 error
	}
	GetPostsWithUnreviewedCommentsStub        func(context.Context, uint64, int) (dbmodels.PostSlice, models.NextPage, error)
	getPostsWithUnreviewedCommentsMutex       sync.RWMutex
	getPostsWithUnreviewedCommentsArgsForCall []struct {
		arg1 context.Context
		arg2 uint64
		arg3 int
	}
	getPostsWithUnreviewedCommentsReturns struct {
		result1 dbmodels.PostSlice
		result2 models.NextPage
		result3 error
	}
	getPostsWithUnreviewedCommentsReturnsOnCall map[int]struct {
		result1 dbmodels.PostSlice
		result2 models.NextPage
		result3 error
	}
	GetReportedUserStub        func(context.Context, models.Posts) (models.Posts, error)
	getReportedUserMutex       sync.RWMutex
	getReportedUserArgsForCall []struct {
		arg1 context.Context
		arg2 models.Posts
	}
	getReportedUserReturns struct {
		result1 models.Posts
		result2 error
	}
	getReportedUserReturnsOnCall map[int]struct {
		result1 models.Posts
		result2 error
	}
	GetReviewedPostsStub        func(context.Context, uint64, time.Time, int) (dbmodels.PostSlice, models.NextPage, error)
	getReviewedPostsMutex       sync.RWMutex
	getReviewedPostsArgsForCall []struct {
		arg1 context.Context
		arg2 uint64
		arg3 time.Time
		arg4 int
	}
	getReviewedPostsReturns struct {
		result1 dbmodels.PostSlice
		result2 models.NextPage
		result3 error
	}
	getReviewedPostsReturnsOnCall map[int]struct {
		result1 dbmodels.PostSlice
		result2 models.NextPage
		result3 error
	}
	GetUnreviewedReportedPostsStub        func(context.Context, uint64, int) (dbmodels.PostSlice, models.NextPage, error)
	getUnreviewedReportedPostsMutex       sync.RWMutex
	getUnreviewedReportedPostsArgsForCall []struct {
		arg1 context.Context
		arg2 uint64
		arg3 int
	}
	getUnreviewedReportedPostsReturns struct {
		result1 dbmodels.PostSlice
		result2 models.NextPage
		result3 error
	}
	getUnreviewedReportedPostsReturnsOnCall map[int]struct {
		result1 dbmodels.PostSlice
		result2 models.NextPage
		result3 error
	}
	GetUserTrackStub        func(context.Context, data.ContentInput) (models.PostCommentTrack, error)
	getUserTrackMutex       sync.RWMutex
	getUserTrackArgsForCall []struct {
		arg1 context.Context
		arg2 data.ContentInput
	}
	getUserTrackReturns struct {
		result1 models.PostCommentTrack
		result2 error
	}
	getUserTrackReturnsOnCall map[int]struct {
		result1 models.PostCommentTrack
		result2 error
	}
	GetUserTrackForContentStub        func(context.Context, data.ManyContentInput) (map[uint64]models.PostCommentTrack, error)
	getUserTrackForContentMutex       sync.RWMutex
	getUserTrackForContentArgsForCall []struct {
		arg1 context.Context
		arg2 data.ManyContentInput
	}
	getUserTrackForContentReturns struct {
		result1 map[uint64]models.PostCommentTrack
		result2 error
	}
	getUserTrackForContentReturnsOnCall map[int]struct {
		result1 map[uint64]models.PostCommentTrack
		result2 error
	}
	NewCommentStub        func(context.Context, *dbmodels.Comment) (*dbmodels.Comment, error)
	newCommentMutex       sync.RWMutex
	newCommentArgsForCall []struct {
		arg1 context.Context
		arg2 *dbmodels.Comment
	}
	newCommentReturns struct {
		result1 *dbmodels.Comment
		result2 error
	}
	newCommentReturnsOnCall map[int]struct {
		result1 *dbmodels.Comment
		result2 error
	}
	NewHiveStub        func(context.Context, *dbmodels.Hive) (*dbmodels.Hive, error)
	newHiveMutex       sync.RWMutex
	newHiveArgsForCall []struct {
		arg1 context.Context
		arg2 *dbmodels.Hive
	}
	newHiveReturns struct {
		result1 *dbmodels.Hive
		result2 error
	}
	newHiveReturnsOnCall map[int]struct {
		result1 *dbmodels.Hive
		result2 error
	}
	NewPostStub        func(context.Context, *dbmodels.Post, dbmodels.TagSlice) (*dbmodels.Post, error)
	newPostMutex       sync.RWMutex
	newPostArgsForCall []struct {
		arg1 context.Context
		arg2 *dbmodels.Post
		arg3 dbmodels.TagSlice
	}
	newPostReturns struct {
		result1 *dbmodels.Post
		result2 error
	}
	newPostReturnsOnCall map[int]struct {
		result1 *dbmodels.Post
		result2 error
	}
	NewPostVideoStub        func(context.Context, *dbmodels.PostVideo) (*dbmodels.PostVideo, error)
	newPostVideoMutex       sync.RWMutex
	newPostVideoArgsForCall []struct {
		arg1 context.Context
		arg2 *dbmodels.PostVideo
	}
	newPostVideoReturns struct {
		result1 *dbmodels.PostVideo
		result2 error
	}
	newPostVideoReturnsOnCall map[int]struct {
		result1 *dbmodels.PostVideo
		result2 error
	}
	PinPostStub        func(context.Context, uint64, uint64, bool) error
	pinPostMutex       sync.RWMutex
	pinPostArgsForCall []struct {
		arg1 context.Context
		arg2 uint64
		arg3 uint64
		arg4 bool
	}
	pinPostReturns struct {
		result1 error
	}
	pinPostReturnsOnCall map[int]struct {
		result1 error
	}
	ReportCommentStub        func(context.Context, uint64, *string, bool) error
	reportCommentMutex       sync.RWMutex
	reportCommentArgsForCall []struct {
		arg1 context.Context
		arg2 uint64
		arg3 *string
		arg4 bool
	}
	reportCommentReturns struct {
		result1 error
	}
	reportCommentReturnsOnCall map[int]struct {
		result1 error
	}
	ReportPostStub        func(context.Context, uint64, *string, bool) error
	reportPostMutex       sync.RWMutex
	reportPostArgsForCall []struct {
		arg1 context.Context
		arg2 uint64
		arg3 *string
		arg4 bool
	}
	reportPostReturns struct {
		result1 error
	}
	reportPostReturnsOnCall map[int]struct {
		result1 error
	}
	TakeDownVoteStub        func(context.Context, data.ContentInput) error
	takeDownVoteMutex       sync.RWMutex
	takeDownVoteArgsForCall []struct {
		arg1 context.Context
		arg2 data.ContentInput
	}
	takeDownVoteReturns struct {
		result1 error
	}
	takeDownVoteReturnsOnCall map[int]struct {
		result1 error
	}
	TakeUpVoteStub        func(context.Context, data.ContentInput) error
	takeUpVoteMutex       sync.RWMutex
	takeUpVoteArgsForCall []struct {
		arg1 context.Context
		arg2 data.ContentInput
	}
	takeUpVoteReturns struct {
		result1 error
	}
	takeUpVoteReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeHiveService) AddDownVote(arg1 context.Context, arg2 data.ContentInput) error {
	fake.addDownVoteMutex.Lock()
	ret, specificReturn := fake.addDownVoteReturnsOnCall[len(fake.addDownVoteArgsForCall)]
	fake.addDownVoteArgsForCall = append(fake.addDownVoteArgsForCall, struct {
		arg1 context.Context
		arg2 data.ContentInput
	}{arg1, arg2})
	stub := fake.AddDownVoteStub
	fakeReturns := fake.addDownVoteReturns
	fake.recordInvocation("AddDownVote", []interface{}{arg1, arg2})
	fake.addDownVoteMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeHiveService) AddDownVoteCallCount() int {
	fake.addDownVoteMutex.RLock()
	defer fake.addDownVoteMutex.RUnlock()
	return len(fake.addDownVoteArgsForCall)
}

func (fake *FakeHiveService) AddDownVoteCalls(stub func(context.Context, data.ContentInput) error) {
	fake.addDownVoteMutex.Lock()
	defer fake.addDownVoteMutex.Unlock()
	fake.AddDownVoteStub = stub
}

func (fake *FakeHiveService) AddDownVoteArgsForCall(i int) (context.Context, data.ContentInput) {
	fake.addDownVoteMutex.RLock()
	defer fake.addDownVoteMutex.RUnlock()
	argsForCall := fake.addDownVoteArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeHiveService) AddDownVoteReturns(result1 error) {
	fake.addDownVoteMutex.Lock()
	defer fake.addDownVoteMutex.Unlock()
	fake.AddDownVoteStub = nil
	fake.addDownVoteReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeHiveService) AddDownVoteReturnsOnCall(i int, result1 error) {
	fake.addDownVoteMutex.Lock()
	defer fake.addDownVoteMutex.Unlock()
	fake.AddDownVoteStub = nil
	if fake.addDownVoteReturnsOnCall == nil {
		fake.addDownVoteReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.addDownVoteReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeHiveService) AddUpVote(arg1 context.Context, arg2 data.ContentInput) error {
	fake.addUpVoteMutex.Lock()
	ret, specificReturn := fake.addUpVoteReturnsOnCall[len(fake.addUpVoteArgsForCall)]
	fake.addUpVoteArgsForCall = append(fake.addUpVoteArgsForCall, struct {
		arg1 context.Context
		arg2 data.ContentInput
	}{arg1, arg2})
	stub := fake.AddUpVoteStub
	fakeReturns := fake.addUpVoteReturns
	fake.recordInvocation("AddUpVote", []interface{}{arg1, arg2})
	fake.addUpVoteMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeHiveService) AddUpVoteCallCount() int {
	fake.addUpVoteMutex.RLock()
	defer fake.addUpVoteMutex.RUnlock()
	return len(fake.addUpVoteArgsForCall)
}

func (fake *FakeHiveService) AddUpVoteCalls(stub func(context.Context, data.ContentInput) error) {
	fake.addUpVoteMutex.Lock()
	defer fake.addUpVoteMutex.Unlock()
	fake.AddUpVoteStub = stub
}

func (fake *FakeHiveService) AddUpVoteArgsForCall(i int) (context.Context, data.ContentInput) {
	fake.addUpVoteMutex.RLock()
	defer fake.addUpVoteMutex.RUnlock()
	argsForCall := fake.addUpVoteArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeHiveService) AddUpVoteReturns(result1 error) {
	fake.addUpVoteMutex.Lock()
	defer fake.addUpVoteMutex.Unlock()
	fake.AddUpVoteStub = nil
	fake.addUpVoteReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeHiveService) AddUpVoteReturnsOnCall(i int, result1 error) {
	fake.addUpVoteMutex.Lock()
	defer fake.addUpVoteMutex.Unlock()
	fake.AddUpVoteStub = nil
	if fake.addUpVoteReturnsOnCall == nil {
		fake.addUpVoteReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.addUpVoteReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeHiveService) DeleteComment(arg1 context.Context, arg2 uint64) error {
	fake.deleteCommentMutex.Lock()
	ret, specificReturn := fake.deleteCommentReturnsOnCall[len(fake.deleteCommentArgsForCall)]
	fake.deleteCommentArgsForCall = append(fake.deleteCommentArgsForCall, struct {
		arg1 context.Context
		arg2 uint64
	}{arg1, arg2})
	stub := fake.DeleteCommentStub
	fakeReturns := fake.deleteCommentReturns
	fake.recordInvocation("DeleteComment", []interface{}{arg1, arg2})
	fake.deleteCommentMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeHiveService) DeleteCommentCallCount() int {
	fake.deleteCommentMutex.RLock()
	defer fake.deleteCommentMutex.RUnlock()
	return len(fake.deleteCommentArgsForCall)
}

func (fake *FakeHiveService) DeleteCommentCalls(stub func(context.Context, uint64) error) {
	fake.deleteCommentMutex.Lock()
	defer fake.deleteCommentMutex.Unlock()
	fake.DeleteCommentStub = stub
}

func (fake *FakeHiveService) DeleteCommentArgsForCall(i int) (context.Context, uint64) {
	fake.deleteCommentMutex.RLock()
	defer fake.deleteCommentMutex.RUnlock()
	argsForCall := fake.deleteCommentArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeHiveService) DeleteCommentReturns(result1 error) {
	fake.deleteCommentMutex.Lock()
	defer fake.deleteCommentMutex.Unlock()
	fake.DeleteCommentStub = nil
	fake.deleteCommentReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeHiveService) DeleteCommentReturnsOnCall(i int, result1 error) {
	fake.deleteCommentMutex.Lock()
	defer fake.deleteCommentMutex.Unlock()
	fake.DeleteCommentStub = nil
	if fake.deleteCommentReturnsOnCall == nil {
		fake.deleteCommentReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteCommentReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeHiveService) DeletePost(arg1 context.Context, arg2 uint64) error {
	fake.deletePostMutex.Lock()
	ret, specificReturn := fake.deletePostReturnsOnCall[len(fake.deletePostArgsForCall)]
	fake.deletePostArgsForCall = append(fake.deletePostArgsForCall, struct {
		arg1 context.Context
		arg2 uint64
	}{arg1, arg2})
	stub := fake.DeletePostStub
	fakeReturns := fake.deletePostReturns
	fake.recordInvocation("DeletePost", []interface{}{arg1, arg2})
	fake.deletePostMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeHiveService) DeletePostCallCount() int {
	fake.deletePostMutex.RLock()
	defer fake.deletePostMutex.RUnlock()
	return len(fake.deletePostArgsForCall)
}

func (fake *FakeHiveService) DeletePostCalls(stub func(context.Context, uint64) error) {
	fake.deletePostMutex.Lock()
	defer fake.deletePostMutex.Unlock()
	fake.DeletePostStub = stub
}

func (fake *FakeHiveService) DeletePostArgsForCall(i int) (context.Context, uint64) {
	fake.deletePostMutex.RLock()
	defer fake.deletePostMutex.RUnlock()
	argsForCall := fake.deletePostArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeHiveService) DeletePostReturns(result1 error) {
	fake.deletePostMutex.Lock()
	defer fake.deletePostMutex.Unlock()
	fake.DeletePostStub = nil
	fake.deletePostReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeHiveService) DeletePostReturnsOnCall(i int, result1 error) {
	fake.deletePostMutex.Lock()
	defer fake.deletePostMutex.Unlock()
	fake.DeletePostStub = nil
	if fake.deletePostReturnsOnCall == nil {
		fake.deletePostReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deletePostReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeHiveService) EditComment(arg1 context.Context, arg2 *dbmodels.Comment) (*dbmodels.Comment, error) {
	fake.editCommentMutex.Lock()
	ret, specificReturn := fake.editCommentReturnsOnCall[len(fake.editCommentArgsForCall)]
	fake.editCommentArgsForCall = append(fake.editCommentArgsForCall, struct {
		arg1 context.Context
		arg2 *dbmodels.Comment
	}{arg1, arg2})
	stub := fake.EditCommentStub
	fakeReturns := fake.editCommentReturns
	fake.recordInvocation("EditComment", []interface{}{arg1, arg2})
	fake.editCommentMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeHiveService) EditCommentCallCount() int {
	fake.editCommentMutex.RLock()
	defer fake.editCommentMutex.RUnlock()
	return len(fake.editCommentArgsForCall)
}

func (fake *FakeHiveService) EditCommentCalls(stub func(context.Context, *dbmodels.Comment) (*dbmodels.Comment, error)) {
	fake.editCommentMutex.Lock()
	defer fake.editCommentMutex.Unlock()
	fake.EditCommentStub = stub
}

func (fake *FakeHiveService) EditCommentArgsForCall(i int) (context.Context, *dbmodels.Comment) {
	fake.editCommentMutex.RLock()
	defer fake.editCommentMutex.RUnlock()
	argsForCall := fake.editCommentArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeHiveService) EditCommentReturns(result1 *dbmodels.Comment, result2 error) {
	fake.editCommentMutex.Lock()
	defer fake.editCommentMutex.Unlock()
	fake.EditCommentStub = nil
	fake.editCommentReturns = struct {
		result1 *dbmodels.Comment
		result2 error
	}{result1, result2}
}

func (fake *FakeHiveService) EditCommentReturnsOnCall(i int, result1 *dbmodels.Comment, result2 error) {
	fake.editCommentMutex.Lock()
	defer fake.editCommentMutex.Unlock()
	fake.EditCommentStub = nil
	if fake.editCommentReturnsOnCall == nil {
		fake.editCommentReturnsOnCall = make(map[int]struct {
			result1 *dbmodels.Comment
			result2 error
		})
	}
	fake.editCommentReturnsOnCall[i] = struct {
		result1 *dbmodels.Comment
		result2 error
	}{result1, result2}
}

func (fake *FakeHiveService) EditHive(arg1 context.Context, arg2 *dbmodels.Hive) (*dbmodels.Hive, error) {
	fake.editHiveMutex.Lock()
	ret, specificReturn := fake.editHiveReturnsOnCall[len(fake.editHiveArgsForCall)]
	fake.editHiveArgsForCall = append(fake.editHiveArgsForCall, struct {
		arg1 context.Context
		arg2 *dbmodels.Hive
	}{arg1, arg2})
	stub := fake.EditHiveStub
	fakeReturns := fake.editHiveReturns
	fake.recordInvocation("EditHive", []interface{}{arg1, arg2})
	fake.editHiveMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeHiveService) EditHiveCallCount() int {
	fake.editHiveMutex.RLock()
	defer fake.editHiveMutex.RUnlock()
	return len(fake.editHiveArgsForCall)
}

func (fake *FakeHiveService) EditHiveCalls(stub func(context.Context, *dbmodels.Hive) (*dbmodels.Hive, error)) {
	fake.editHiveMutex.Lock()
	defer fake.editHiveMutex.Unlock()
	fake.EditHiveStub = stub
}

func (fake *FakeHiveService) EditHiveArgsForCall(i int) (context.Context, *dbmodels.Hive) {
	fake.editHiveMutex.RLock()
	defer fake.editHiveMutex.RUnlock()
	argsForCall := fake.editHiveArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeHiveService) EditHiveReturns(result1 *dbmodels.Hive, result2 error) {
	fake.editHiveMutex.Lock()
	defer fake.editHiveMutex.Unlock()
	fake.EditHiveStub = nil
	fake.editHiveReturns = struct {
		result1 *dbmodels.Hive
		result2 error
	}{result1, result2}
}

func (fake *FakeHiveService) EditHiveReturnsOnCall(i int, result1 *dbmodels.Hive, result2 error) {
	fake.editHiveMutex.Lock()
	defer fake.editHiveMutex.Unlock()
	fake.EditHiveStub = nil
	if fake.editHiveReturnsOnCall == nil {
		fake.editHiveReturnsOnCall = make(map[int]struct {
			result1 *dbmodels.Hive
			result2 error
		})
	}
	fake.editHiveReturnsOnCall[i] = struct {
		result1 *dbmodels.Hive
		result2 error
	}{result1, result2}
}

func (fake *FakeHiveService) EditPost(arg1 context.Context, arg2 *dbmodels.Post, arg3 dbmodels.TagSlice) (*dbmodels.Post, error) {
	fake.editPostMutex.Lock()
	ret, specificReturn := fake.editPostReturnsOnCall[len(fake.editPostArgsForCall)]
	fake.editPostArgsForCall = append(fake.editPostArgsForCall, struct {
		arg1 context.Context
		arg2 *dbmodels.Post
		arg3 dbmodels.TagSlice
	}{arg1, arg2, arg3})
	stub := fake.EditPostStub
	fakeReturns := fake.editPostReturns
	fake.recordInvocation("EditPost", []interface{}{arg1, arg2, arg3})
	fake.editPostMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeHiveService) EditPostCallCount() int {
	fake.editPostMutex.RLock()
	defer fake.editPostMutex.RUnlock()
	return len(fake.editPostArgsForCall)
}

func (fake *FakeHiveService) EditPostCalls(stub func(context.Context, *dbmodels.Post, dbmodels.TagSlice) (*dbmodels.Post, error)) {
	fake.editPostMutex.Lock()
	defer fake.editPostMutex.Unlock()
	fake.EditPostStub = stub
}

func (fake *FakeHiveService) EditPostArgsForCall(i int) (context.Context, *dbmodels.Post, dbmodels.TagSlice) {
	fake.editPostMutex.RLock()
	defer fake.editPostMutex.RUnlock()
	argsForCall := fake.editPostArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeHiveService) EditPostReturns(result1 *dbmodels.Post, result2 error) {
	fake.editPostMutex.Lock()
	defer fake.editPostMutex.Unlock()
	fake.EditPostStub = nil
	fake.editPostReturns = struct {
		result1 *dbmodels.Post
		result2 error
	}{result1, result2}
}

func (fake *FakeHiveService) EditPostReturnsOnCall(i int, result1 *dbmodels.Post, result2 error) {
	fake.editPostMutex.Lock()
	defer fake.editPostMutex.Unlock()
	fake.EditPostStub = nil
	if fake.editPostReturnsOnCall == nil {
		fake.editPostReturnsOnCall = make(map[int]struct {
			result1 *dbmodels.Post
			result2 error
		})
	}
	fake.editPostReturnsOnCall[i] = struct {
		result1 *dbmodels.Post
		result2 error
	}{result1, result2}
}

func (fake *FakeHiveService) GetComment(arg1 context.Context, arg2 uint64) (*dbmodels.Comment, error) {
	fake.getCommentMutex.Lock()
	ret, specificReturn := fake.getCommentReturnsOnCall[len(fake.getCommentArgsForCall)]
	fake.getCommentArgsForCall = append(fake.getCommentArgsForCall, struct {
		arg1 context.Context
		arg2 uint64
	}{arg1, arg2})
	stub := fake.GetCommentStub
	fakeReturns := fake.getCommentReturns
	fake.recordInvocation("GetComment", []interface{}{arg1, arg2})
	fake.getCommentMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeHiveService) GetCommentCallCount() int {
	fake.getCommentMutex.RLock()
	defer fake.getCommentMutex.RUnlock()
	return len(fake.getCommentArgsForCall)
}

func (fake *FakeHiveService) GetCommentCalls(stub func(context.Context, uint64) (*dbmodels.Comment, error)) {
	fake.getCommentMutex.Lock()
	defer fake.getCommentMutex.Unlock()
	fake.GetCommentStub = stub
}

func (fake *FakeHiveService) GetCommentArgsForCall(i int) (context.Context, uint64) {
	fake.getCommentMutex.RLock()
	defer fake.getCommentMutex.RUnlock()
	argsForCall := fake.getCommentArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeHiveService) GetCommentReturns(result1 *dbmodels.Comment, result2 error) {
	fake.getCommentMutex.Lock()
	defer fake.getCommentMutex.Unlock()
	fake.GetCommentStub = nil
	fake.getCommentReturns = struct {
		result1 *dbmodels.Comment
		result2 error
	}{result1, result2}
}

func (fake *FakeHiveService) GetCommentReturnsOnCall(i int, result1 *dbmodels.Comment, result2 error) {
	fake.getCommentMutex.Lock()
	defer fake.getCommentMutex.Unlock()
	fake.GetCommentStub = nil
	if fake.getCommentReturnsOnCall == nil {
		fake.getCommentReturnsOnCall = make(map[int]struct {
			result1 *dbmodels.Comment
			result2 error
		})
	}
	fake.getCommentReturnsOnCall[i] = struct {
		result1 *dbmodels.Comment
		result2 error
	}{result1, result2}
}

func (fake *FakeHiveService) GetComments(arg1 context.Context, arg2 uint64, arg3 int, arg4 int) (dbmodels.CommentSlice, *models.NextPage, error) {
	fake.getCommentsMutex.Lock()
	ret, specificReturn := fake.getCommentsReturnsOnCall[len(fake.getCommentsArgsForCall)]
	fake.getCommentsArgsForCall = append(fake.getCommentsArgsForCall, struct {
		arg1 context.Context
		arg2 uint64
		arg3 int
		arg4 int
	}{arg1, arg2, arg3, arg4})
	stub := fake.GetCommentsStub
	fakeReturns := fake.getCommentsReturns
	fake.recordInvocation("GetComments", []interface{}{arg1, arg2, arg3, arg4})
	fake.getCommentsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeHiveService) GetCommentsCallCount() int {
	fake.getCommentsMutex.RLock()
	defer fake.getCommentsMutex.RUnlock()
	return len(fake.getCommentsArgsForCall)
}

func (fake *FakeHiveService) GetCommentsCalls(stub func(context.Context, uint64, int, int) (dbmodels.CommentSlice, *models.NextPage, error)) {
	fake.getCommentsMutex.Lock()
	defer fake.getCommentsMutex.Unlock()
	fake.GetCommentsStub = stub
}

func (fake *FakeHiveService) GetCommentsArgsForCall(i int) (context.Context, uint64, int, int) {
	fake.getCommentsMutex.RLock()
	defer fake.getCommentsMutex.RUnlock()
	argsForCall := fake.getCommentsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeHiveService) GetCommentsReturns(result1 dbmodels.CommentSlice, result2 *models.NextPage, result3 error) {
	fake.getCommentsMutex.Lock()
	defer fake.getCommentsMutex.Unlock()
	fake.GetCommentsStub = nil
	fake.getCommentsReturns = struct {
		result1 dbmodels.CommentSlice
		result2 *models.NextPage
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeHiveService) GetCommentsReturnsOnCall(i int, result1 dbmodels.CommentSlice, result2 *models.NextPage, result3 error) {
	fake.getCommentsMutex.Lock()
	defer fake.getCommentsMutex.Unlock()
	fake.GetCommentsStub = nil
	if fake.getCommentsReturnsOnCall == nil {
		fake.getCommentsReturnsOnCall = make(map[int]struct {
			result1 dbmodels.CommentSlice
			result2 *models.NextPage
			result3 error
		})
	}
	fake.getCommentsReturnsOnCall[i] = struct {
		result1 dbmodels.CommentSlice
		result2 *models.NextPage
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeHiveService) GetHive(arg1 context.Context, arg2 uint64) (*dbmodels.Hive, error) {
	fake.getHiveMutex.Lock()
	ret, specificReturn := fake.getHiveReturnsOnCall[len(fake.getHiveArgsForCall)]
	fake.getHiveArgsForCall = append(fake.getHiveArgsForCall, struct {
		arg1 context.Context
		arg2 uint64
	}{arg1, arg2})
	stub := fake.GetHiveStub
	fakeReturns := fake.getHiveReturns
	fake.recordInvocation("GetHive", []interface{}{arg1, arg2})
	fake.getHiveMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeHiveService) GetHiveCallCount() int {
	fake.getHiveMutex.RLock()
	defer fake.getHiveMutex.RUnlock()
	return len(fake.getHiveArgsForCall)
}

func (fake *FakeHiveService) GetHiveCalls(stub func(context.Context, uint64) (*dbmodels.Hive, error)) {
	fake.getHiveMutex.Lock()
	defer fake.getHiveMutex.Unlock()
	fake.GetHiveStub = stub
}

func (fake *FakeHiveService) GetHiveArgsForCall(i int) (context.Context, uint64) {
	fake.getHiveMutex.RLock()
	defer fake.getHiveMutex.RUnlock()
	argsForCall := fake.getHiveArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeHiveService) GetHiveReturns(result1 *dbmodels.Hive, result2 error) {
	fake.getHiveMutex.Lock()
	defer fake.getHiveMutex.Unlock()
	fake.GetHiveStub = nil
	fake.getHiveReturns = struct {
		result1 *dbmodels.Hive
		result2 error
	}{result1, result2}
}

func (fake *FakeHiveService) GetHiveReturnsOnCall(i int, result1 *dbmodels.Hive, result2 error) {
	fake.getHiveMutex.Lock()
	defer fake.getHiveMutex.Unlock()
	fake.GetHiveStub = nil
	if fake.getHiveReturnsOnCall == nil {
		fake.getHiveReturnsOnCall = make(map[int]struct {
			result1 *dbmodels.Hive
			result2 error
		})
	}
	fake.getHiveReturnsOnCall[i] = struct {
		result1 *dbmodels.Hive
		result2 error
	}{result1, result2}
}

func (fake *FakeHiveService) GetHives(arg1 context.Context) (dbmodels.HiveSlice, error) {
	fake.getHivesMutex.Lock()
	ret, specificReturn := fake.getHivesReturnsOnCall[len(fake.getHivesArgsForCall)]
	fake.getHivesArgsForCall = append(fake.getHivesArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.GetHivesStub
	fakeReturns := fake.getHivesReturns
	fake.recordInvocation("GetHives", []interface{}{arg1})
	fake.getHivesMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeHiveService) GetHivesCallCount() int {
	fake.getHivesMutex.RLock()
	defer fake.getHivesMutex.RUnlock()
	return len(fake.getHivesArgsForCall)
}

func (fake *FakeHiveService) GetHivesCalls(stub func(context.Context) (dbmodels.HiveSlice, error)) {
	fake.getHivesMutex.Lock()
	defer fake.getHivesMutex.Unlock()
	fake.GetHivesStub = stub
}

func (fake *FakeHiveService) GetHivesArgsForCall(i int) context.Context {
	fake.getHivesMutex.RLock()
	defer fake.getHivesMutex.RUnlock()
	argsForCall := fake.getHivesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeHiveService) GetHivesReturns(result1 dbmodels.HiveSlice, result2 error) {
	fake.getHivesMutex.Lock()
	defer fake.getHivesMutex.Unlock()
	fake.GetHivesStub = nil
	fake.getHivesReturns = struct {
		result1 dbmodels.HiveSlice
		result2 error
	}{result1, result2}
}

func (fake *FakeHiveService) GetHivesReturnsOnCall(i int, result1 dbmodels.HiveSlice, result2 error) {
	fake.getHivesMutex.Lock()
	defer fake.getHivesMutex.Unlock()
	fake.GetHivesStub = nil
	if fake.getHivesReturnsOnCall == nil {
		fake.getHivesReturnsOnCall = make(map[int]struct {
			result1 dbmodels.HiveSlice
			result2 error
		})
	}
	fake.getHivesReturnsOnCall[i] = struct {
		result1 dbmodels.HiveSlice
		result2 error
	}{result1, result2}
}

func (fake *FakeHiveService) GetPost(arg1 context.Context, arg2 uint64) (*dbmodels.Post, error) {
	fake.getPostMutex.Lock()
	ret, specificReturn := fake.getPostReturnsOnCall[len(fake.getPostArgsForCall)]
	fake.getPostArgsForCall = append(fake.getPostArgsForCall, struct {
		arg1 context.Context
		arg2 uint64
	}{arg1, arg2})
	stub := fake.GetPostStub
	fakeReturns := fake.getPostReturns
	fake.recordInvocation("GetPost", []interface{}{arg1, arg2})
	fake.getPostMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeHiveService) GetPostCallCount() int {
	fake.getPostMutex.RLock()
	defer fake.getPostMutex.RUnlock()
	return len(fake.getPostArgsForCall)
}

func (fake *FakeHiveService) GetPostCalls(stub func(context.Context, uint64) (*dbmodels.Post, error)) {
	fake.getPostMutex.Lock()
	defer fake.getPostMutex.Unlock()
	fake.GetPostStub = stub
}

func (fake *FakeHiveService) GetPostArgsForCall(i int) (context.Context, uint64) {
	fake.getPostMutex.RLock()
	defer fake.getPostMutex.RUnlock()
	argsForCall := fake.getPostArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeHiveService) GetPostReturns(result1 *dbmodels.Post, result2 error) {
	fake.getPostMutex.Lock()
	defer fake.getPostMutex.Unlock()
	fake.GetPostStub = nil
	fake.getPostReturns = struct {
		result1 *dbmodels.Post
		result2 error
	}{result1, result2}
}

func (fake *FakeHiveService) GetPostReturnsOnCall(i int, result1 *dbmodels.Post, result2 error) {
	fake.getPostMutex.Lock()
	defer fake.getPostMutex.Unlock()
	fake.GetPostStub = nil
	if fake.getPostReturnsOnCall == nil {
		fake.getPostReturnsOnCall = make(map[int]struct {
			result1 *dbmodels.Post
			result2 error
		})
	}
	fake.getPostReturnsOnCall[i] = struct {
		result1 *dbmodels.Post
		result2 error
	}{result1, result2}
}

func (fake *FakeHiveService) GetPosts(arg1 context.Context, arg2 data.GetPostsInput) (dbmodels.PostSlice, *models.NextPage, error) {
	fake.getPostsMutex.Lock()
	ret, specificReturn := fake.getPostsReturnsOnCall[len(fake.getPostsArgsForCall)]
	fake.getPostsArgsForCall = append(fake.getPostsArgsForCall, struct {
		arg1 context.Context
		arg2 data.GetPostsInput
	}{arg1, arg2})
	stub := fake.GetPostsStub
	fakeReturns := fake.getPostsReturns
	fake.recordInvocation("GetPosts", []interface{}{arg1, arg2})
	fake.getPostsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeHiveService) GetPostsCallCount() int {
	fake.getPostsMutex.RLock()
	defer fake.getPostsMutex.RUnlock()
	return len(fake.getPostsArgsForCall)
}

func (fake *FakeHiveService) GetPostsCalls(stub func(context.Context, data.GetPostsInput) (dbmodels.PostSlice, *models.NextPage, error)) {
	fake.getPostsMutex.Lock()
	defer fake.getPostsMutex.Unlock()
	fake.GetPostsStub = stub
}

func (fake *FakeHiveService) GetPostsArgsForCall(i int) (context.Context, data.GetPostsInput) {
	fake.getPostsMutex.RLock()
	defer fake.getPostsMutex.RUnlock()
	argsForCall := fake.getPostsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeHiveService) GetPostsReturns(result1 dbmodels.PostSlice, result2 *models.NextPage, result3 error) {
	fake.getPostsMutex.Lock()
	defer fake.getPostsMutex.Unlock()
	fake.GetPostsStub = nil
	fake.getPostsReturns = struct {
		result1 dbmodels.PostSlice
		result2 *models.NextPage
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeHiveService) GetPostsReturnsOnCall(i int, result1 dbmodels.PostSlice, result2 *models.NextPage, result3 error) {
	fake.getPostsMutex.Lock()
	defer fake.getPostsMutex.Unlock()
	fake.GetPostsStub = nil
	if fake.getPostsReturnsOnCall == nil {
		fake.getPostsReturnsOnCall = make(map[int]struct {
			result1 dbmodels.PostSlice
			result2 *models.NextPage
			result3 error
		})
	}
	fake.getPostsReturnsOnCall[i] = struct {
		result1 dbmodels.PostSlice
		result2 *models.NextPage
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeHiveService) GetPostsWithReviewedComments(arg1 context.Context, arg2 uint64, arg3 time.Time, arg4 int) (dbmodels.PostSlice, models.NextPage, error) {
	fake.getPostsWithReviewedCommentsMutex.Lock()
	ret, specificReturn := fake.getPostsWithReviewedCommentsReturnsOnCall[len(fake.getPostsWithReviewedCommentsArgsForCall)]
	fake.getPostsWithReviewedCommentsArgsForCall = append(fake.getPostsWithReviewedCommentsArgsForCall, struct {
		arg1 context.Context
		arg2 uint64
		arg3 time.Time
		arg4 int
	}{arg1, arg2, arg3, arg4})
	stub := fake.GetPostsWithReviewedCommentsStub
	fakeReturns := fake.getPostsWithReviewedCommentsReturns
	fake.recordInvocation("GetPostsWithReviewedComments", []interface{}{arg1, arg2, arg3, arg4})
	fake.getPostsWithReviewedCommentsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeHiveService) GetPostsWithReviewedCommentsCallCount() int {
	fake.getPostsWithReviewedCommentsMutex.RLock()
	defer fake.getPostsWithReviewedCommentsMutex.RUnlock()
	return len(fake.getPostsWithReviewedCommentsArgsForCall)
}

func (fake *FakeHiveService) GetPostsWithReviewedCommentsCalls(stub func(context.Context, uint64, time.Time, int) (dbmodels.PostSlice, models.NextPage, error)) {
	fake.getPostsWithReviewedCommentsMutex.Lock()
	defer fake.getPostsWithReviewedCommentsMutex.Unlock()
	fake.GetPostsWithReviewedCommentsStub = stub
}

func (fake *FakeHiveService) GetPostsWithReviewedCommentsArgsForCall(i int) (context.Context, uint64, time.Time, int) {
	fake.getPostsWithReviewedCommentsMutex.RLock()
	defer fake.getPostsWithReviewedCommentsMutex.RUnlock()
	argsForCall := fake.getPostsWithReviewedCommentsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeHiveService) GetPostsWithReviewedCommentsReturns(result1 dbmodels.PostSlice, result2 models.NextPage, result3 error) {
	fake.getPostsWithReviewedCommentsMutex.Lock()
	defer fake.getPostsWithReviewedCommentsMutex.Unlock()
	fake.GetPostsWithReviewedCommentsStub = nil
	fake.getPostsWithReviewedCommentsReturns = struct {
		result1 dbmodels.PostSlice
		result2 models.NextPage
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeHiveService) GetPostsWithReviewedCommentsReturnsOnCall(i int, result1 dbmodels.PostSlice, result2 models.NextPage, result3 error) {
	fake.getPostsWithReviewedCommentsMutex.Lock()
	defer fake.getPostsWithReviewedCommentsMutex.Unlock()
	fake.GetPostsWithReviewedCommentsStub = nil
	if fake.getPostsWithReviewedCommentsReturnsOnCall == nil {
		fake.getPostsWithReviewedCommentsReturnsOnCall = make(map[int]struct {
			result1 dbmodels.PostSlice
			result2 models.NextPage
			result3 error
		})
	}
	fake.getPostsWithReviewedCommentsReturnsOnCall[i] = struct {
		result1 dbmodels.PostSlice
		result2 models.NextPage
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeHiveService) GetPostsWithUnreviewedComments(arg1 context.Context, arg2 uint64, arg3 int) (dbmodels.PostSlice, models.NextPage, error) {
	fake.getPostsWithUnreviewedCommentsMutex.Lock()
	ret, specificReturn := fake.getPostsWithUnreviewedCommentsReturnsOnCall[len(fake.getPostsWithUnreviewedCommentsArgsForCall)]
	fake.getPostsWithUnreviewedCommentsArgsForCall = append(fake.getPostsWithUnreviewedCommentsArgsForCall, struct {
		arg1 context.Context
		arg2 uint64
		arg3 int
	}{arg1, arg2, arg3})
	stub := fake.GetPostsWithUnreviewedCommentsStub
	fakeReturns := fake.getPostsWithUnreviewedCommentsReturns
	fake.recordInvocation("GetPostsWithUnreviewedComments", []interface{}{arg1, arg2, arg3})
	fake.getPostsWithUnreviewedCommentsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeHiveService) GetPostsWithUnreviewedCommentsCallCount() int {
	fake.getPostsWithUnreviewedCommentsMutex.RLock()
	defer fake.getPostsWithUnreviewedCommentsMutex.RUnlock()
	return len(fake.getPostsWithUnreviewedCommentsArgsForCall)
}

func (fake *FakeHiveService) GetPostsWithUnreviewedCommentsCalls(stub func(context.Context, uint64, int) (dbmodels.PostSlice, models.NextPage, error)) {
	fake.getPostsWithUnreviewedCommentsMutex.Lock()
	defer fake.getPostsWithUnreviewedCommentsMutex.Unlock()
	fake.GetPostsWithUnreviewedCommentsStub = stub
}

func (fake *FakeHiveService) GetPostsWithUnreviewedCommentsArgsForCall(i int) (context.Context, uint64, int) {
	fake.getPostsWithUnreviewedCommentsMutex.RLock()
	defer fake.getPostsWithUnreviewedCommentsMutex.RUnlock()
	argsForCall := fake.getPostsWithUnreviewedCommentsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeHiveService) GetPostsWithUnreviewedCommentsReturns(result1 dbmodels.PostSlice, result2 models.NextPage, result3 error) {
	fake.getPostsWithUnreviewedCommentsMutex.Lock()
	defer fake.getPostsWithUnreviewedCommentsMutex.Unlock()
	fake.GetPostsWithUnreviewedCommentsStub = nil
	fake.getPostsWithUnreviewedCommentsReturns = struct {
		result1 dbmodels.PostSlice
		result2 models.NextPage
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeHiveService) GetPostsWithUnreviewedCommentsReturnsOnCall(i int, result1 dbmodels.PostSlice, result2 models.NextPage, result3 error) {
	fake.getPostsWithUnreviewedCommentsMutex.Lock()
	defer fake.getPostsWithUnreviewedCommentsMutex.Unlock()
	fake.GetPostsWithUnreviewedCommentsStub = nil
	if fake.getPostsWithUnreviewedCommentsReturnsOnCall == nil {
		fake.getPostsWithUnreviewedCommentsReturnsOnCall = make(map[int]struct {
			result1 dbmodels.PostSlice
			result2 models.NextPage
			result3 error
		})
	}
	fake.getPostsWithUnreviewedCommentsReturnsOnCall[i] = struct {
		result1 dbmodels.PostSlice
		result2 models.NextPage
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeHiveService) GetReportedUser(arg1 context.Context, arg2 models.Posts) (models.Posts, error) {
	fake.getReportedUserMutex.Lock()
	ret, specificReturn := fake.getReportedUserReturnsOnCall[len(fake.getReportedUserArgsForCall)]
	fake.getReportedUserArgsForCall = append(fake.getReportedUserArgsForCall, struct {
		arg1 context.Context
		arg2 models.Posts
	}{arg1, arg2})
	stub := fake.GetReportedUserStub
	fakeReturns := fake.getReportedUserReturns
	fake.recordInvocation("GetReportedUser", []interface{}{arg1, arg2})
	fake.getReportedUserMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeHiveService) GetReportedUserCallCount() int {
	fake.getReportedUserMutex.RLock()
	defer fake.getReportedUserMutex.RUnlock()
	return len(fake.getReportedUserArgsForCall)
}

func (fake *FakeHiveService) GetReportedUserCalls(stub func(context.Context, models.Posts) (models.Posts, error)) {
	fake.getReportedUserMutex.Lock()
	defer fake.getReportedUserMutex.Unlock()
	fake.GetReportedUserStub = stub
}

func (fake *FakeHiveService) GetReportedUserArgsForCall(i int) (context.Context, models.Posts) {
	fake.getReportedUserMutex.RLock()
	defer fake.getReportedUserMutex.RUnlock()
	argsForCall := fake.getReportedUserArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeHiveService) GetReportedUserReturns(result1 models.Posts, result2 error) {
	fake.getReportedUserMutex.Lock()
	defer fake.getReportedUserMutex.Unlock()
	fake.GetReportedUserStub = nil
	fake.getReportedUserReturns = struct {
		result1 models.Posts
		result2 error
	}{result1, result2}
}

func (fake *FakeHiveService) GetReportedUserReturnsOnCall(i int, result1 models.Posts, result2 error) {
	fake.getReportedUserMutex.Lock()
	defer fake.getReportedUserMutex.Unlock()
	fake.GetReportedUserStub = nil
	if fake.getReportedUserReturnsOnCall == nil {
		fake.getReportedUserReturnsOnCall = make(map[int]struct {
			result1 models.Posts
			result2 error
		})
	}
	fake.getReportedUserReturnsOnCall[i] = struct {
		result1 models.Posts
		result2 error
	}{result1, result2}
}

func (fake *FakeHiveService) GetReviewedPosts(arg1 context.Context, arg2 uint64, arg3 time.Time, arg4 int) (dbmodels.PostSlice, models.NextPage, error) {
	fake.getReviewedPostsMutex.Lock()
	ret, specificReturn := fake.getReviewedPostsReturnsOnCall[len(fake.getReviewedPostsArgsForCall)]
	fake.getReviewedPostsArgsForCall = append(fake.getReviewedPostsArgsForCall, struct {
		arg1 context.Context
		arg2 uint64
		arg3 time.Time
		arg4 int
	}{arg1, arg2, arg3, arg4})
	stub := fake.GetReviewedPostsStub
	fakeReturns := fake.getReviewedPostsReturns
	fake.recordInvocation("GetReviewedPosts", []interface{}{arg1, arg2, arg3, arg4})
	fake.getReviewedPostsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeHiveService) GetReviewedPostsCallCount() int {
	fake.getReviewedPostsMutex.RLock()
	defer fake.getReviewedPostsMutex.RUnlock()
	return len(fake.getReviewedPostsArgsForCall)
}

func (fake *FakeHiveService) GetReviewedPostsCalls(stub func(context.Context, uint64, time.Time, int) (dbmodels.PostSlice, models.NextPage, error)) {
	fake.getReviewedPostsMutex.Lock()
	defer fake.getReviewedPostsMutex.Unlock()
	fake.GetReviewedPostsStub = stub
}

func (fake *FakeHiveService) GetReviewedPostsArgsForCall(i int) (context.Context, uint64, time.Time, int) {
	fake.getReviewedPostsMutex.RLock()
	defer fake.getReviewedPostsMutex.RUnlock()
	argsForCall := fake.getReviewedPostsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeHiveService) GetReviewedPostsReturns(result1 dbmodels.PostSlice, result2 models.NextPage, result3 error) {
	fake.getReviewedPostsMutex.Lock()
	defer fake.getReviewedPostsMutex.Unlock()
	fake.GetReviewedPostsStub = nil
	fake.getReviewedPostsReturns = struct {
		result1 dbmodels.PostSlice
		result2 models.NextPage
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeHiveService) GetReviewedPostsReturnsOnCall(i int, result1 dbmodels.PostSlice, result2 models.NextPage, result3 error) {
	fake.getReviewedPostsMutex.Lock()
	defer fake.getReviewedPostsMutex.Unlock()
	fake.GetReviewedPostsStub = nil
	if fake.getReviewedPostsReturnsOnCall == nil {
		fake.getReviewedPostsReturnsOnCall = make(map[int]struct {
			result1 dbmodels.PostSlice
			result2 models.NextPage
			result3 error
		})
	}
	fake.getReviewedPostsReturnsOnCall[i] = struct {
		result1 dbmodels.PostSlice
		result2 models.NextPage
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeHiveService) GetUnreviewedReportedPosts(arg1 context.Context, arg2 uint64, arg3 int) (dbmodels.PostSlice, models.NextPage, error) {
	fake.getUnreviewedReportedPostsMutex.Lock()
	ret, specificReturn := fake.getUnreviewedReportedPostsReturnsOnCall[len(fake.getUnreviewedReportedPostsArgsForCall)]
	fake.getUnreviewedReportedPostsArgsForCall = append(fake.getUnreviewedReportedPostsArgsForCall, struct {
		arg1 context.Context
		arg2 uint64
		arg3 int
	}{arg1, arg2, arg3})
	stub := fake.GetUnreviewedReportedPostsStub
	fakeReturns := fake.getUnreviewedReportedPostsReturns
	fake.recordInvocation("GetUnreviewedReportedPosts", []interface{}{arg1, arg2, arg3})
	fake.getUnreviewedReportedPostsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeHiveService) GetUnreviewedReportedPostsCallCount() int {
	fake.getUnreviewedReportedPostsMutex.RLock()
	defer fake.getUnreviewedReportedPostsMutex.RUnlock()
	return len(fake.getUnreviewedReportedPostsArgsForCall)
}

func (fake *FakeHiveService) GetUnreviewedReportedPostsCalls(stub func(context.Context, uint64, int) (dbmodels.PostSlice, models.NextPage, error)) {
	fake.getUnreviewedReportedPostsMutex.Lock()
	defer fake.getUnreviewedReportedPostsMutex.Unlock()
	fake.GetUnreviewedReportedPostsStub = stub
}

func (fake *FakeHiveService) GetUnreviewedReportedPostsArgsForCall(i int) (context.Context, uint64, int) {
	fake.getUnreviewedReportedPostsMutex.RLock()
	defer fake.getUnreviewedReportedPostsMutex.RUnlock()
	argsForCall := fake.getUnreviewedReportedPostsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeHiveService) GetUnreviewedReportedPostsReturns(result1 dbmodels.PostSlice, result2 models.NextPage, result3 error) {
	fake.getUnreviewedReportedPostsMutex.Lock()
	defer fake.getUnreviewedReportedPostsMutex.Unlock()
	fake.GetUnreviewedReportedPostsStub = nil
	fake.getUnreviewedReportedPostsReturns = struct {
		result1 dbmodels.PostSlice
		result2 models.NextPage
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeHiveService) GetUnreviewedReportedPostsReturnsOnCall(i int, result1 dbmodels.PostSlice, result2 models.NextPage, result3 error) {
	fake.getUnreviewedReportedPostsMutex.Lock()
	defer fake.getUnreviewedReportedPostsMutex.Unlock()
	fake.GetUnreviewedReportedPostsStub = nil
	if fake.getUnreviewedReportedPostsReturnsOnCall == nil {
		fake.getUnreviewedReportedPostsReturnsOnCall = make(map[int]struct {
			result1 dbmodels.PostSlice
			result2 models.NextPage
			result3 error
		})
	}
	fake.getUnreviewedReportedPostsReturnsOnCall[i] = struct {
		result1 dbmodels.PostSlice
		result2 models.NextPage
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeHiveService) GetUserTrack(arg1 context.Context, arg2 data.ContentInput) (models.PostCommentTrack, error) {
	fake.getUserTrackMutex.Lock()
	ret, specificReturn := fake.getUserTrackReturnsOnCall[len(fake.getUserTrackArgsForCall)]
	fake.getUserTrackArgsForCall = append(fake.getUserTrackArgsForCall, struct {
		arg1 context.Context
		arg2 data.ContentInput
	}{arg1, arg2})
	stub := fake.GetUserTrackStub
	fakeReturns := fake.getUserTrackReturns
	fake.recordInvocation("GetUserTrack", []interface{}{arg1, arg2})
	fake.getUserTrackMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeHiveService) GetUserTrackCallCount() int {
	fake.getUserTrackMutex.RLock()
	defer fake.getUserTrackMutex.RUnlock()
	return len(fake.getUserTrackArgsForCall)
}

func (fake *FakeHiveService) GetUserTrackCalls(stub func(context.Context, data.ContentInput) (models.PostCommentTrack, error)) {
	fake.getUserTrackMutex.Lock()
	defer fake.getUserTrackMutex.Unlock()
	fake.GetUserTrackStub = stub
}

func (fake *FakeHiveService) GetUserTrackArgsForCall(i int) (context.Context, data.ContentInput) {
	fake.getUserTrackMutex.RLock()
	defer fake.getUserTrackMutex.RUnlock()
	argsForCall := fake.getUserTrackArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeHiveService) GetUserTrackReturns(result1 models.PostCommentTrack, result2 error) {
	fake.getUserTrackMutex.Lock()
	defer fake.getUserTrackMutex.Unlock()
	fake.GetUserTrackStub = nil
	fake.getUserTrackReturns = struct {
		result1 models.PostCommentTrack
		result2 error
	}{result1, result2}
}

func (fake *FakeHiveService) GetUserTrackReturnsOnCall(i int, result1 models.PostCommentTrack, result2 error) {
	fake.getUserTrackMutex.Lock()
	defer fake.getUserTrackMutex.Unlock()
	fake.GetUserTrackStub = nil
	if fake.getUserTrackReturnsOnCall == nil {
		fake.getUserTrackReturnsOnCall = make(map[int]struct {
			result1 models.PostCommentTrack
			result2 error
		})
	}
	fake.getUserTrackReturnsOnCall[i] = struct {
		result1 models.PostCommentTrack
		result2 error
	}{result1, result2}
}

func (fake *FakeHiveService) GetUserTrackForContent(arg1 context.Context, arg2 data.ManyContentInput) (map[uint64]models.PostCommentTrack, error) {
	fake.getUserTrackForContentMutex.Lock()
	ret, specificReturn := fake.getUserTrackForContentReturnsOnCall[len(fake.getUserTrackForContentArgsForCall)]
	fake.getUserTrackForContentArgsForCall = append(fake.getUserTrackForContentArgsForCall, struct {
		arg1 context.Context
		arg2 data.ManyContentInput
	}{arg1, arg2})
	stub := fake.GetUserTrackForContentStub
	fakeReturns := fake.getUserTrackForContentReturns
	fake.recordInvocation("GetUserTrackForContent", []interface{}{arg1, arg2})
	fake.getUserTrackForContentMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeHiveService) GetUserTrackForContentCallCount() int {
	fake.getUserTrackForContentMutex.RLock()
	defer fake.getUserTrackForContentMutex.RUnlock()
	return len(fake.getUserTrackForContentArgsForCall)
}

func (fake *FakeHiveService) GetUserTrackForContentCalls(stub func(context.Context, data.ManyContentInput) (map[uint64]models.PostCommentTrack, error)) {
	fake.getUserTrackForContentMutex.Lock()
	defer fake.getUserTrackForContentMutex.Unlock()
	fake.GetUserTrackForContentStub = stub
}

func (fake *FakeHiveService) GetUserTrackForContentArgsForCall(i int) (context.Context, data.ManyContentInput) {
	fake.getUserTrackForContentMutex.RLock()
	defer fake.getUserTrackForContentMutex.RUnlock()
	argsForCall := fake.getUserTrackForContentArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeHiveService) GetUserTrackForContentReturns(result1 map[uint64]models.PostCommentTrack, result2 error) {
	fake.getUserTrackForContentMutex.Lock()
	defer fake.getUserTrackForContentMutex.Unlock()
	fake.GetUserTrackForContentStub = nil
	fake.getUserTrackForContentReturns = struct {
		result1 map[uint64]models.PostCommentTrack
		result2 error
	}{result1, result2}
}

func (fake *FakeHiveService) GetUserTrackForContentReturnsOnCall(i int, result1 map[uint64]models.PostCommentTrack, result2 error) {
	fake.getUserTrackForContentMutex.Lock()
	defer fake.getUserTrackForContentMutex.Unlock()
	fake.GetUserTrackForContentStub = nil
	if fake.getUserTrackForContentReturnsOnCall == nil {
		fake.getUserTrackForContentReturnsOnCall = make(map[int]struct {
			result1 map[uint64]models.PostCommentTrack
			result2 error
		})
	}
	fake.getUserTrackForContentReturnsOnCall[i] = struct {
		result1 map[uint64]models.PostCommentTrack
		result2 error
	}{result1, result2}
}

func (fake *FakeHiveService) NewComment(arg1 context.Context, arg2 *dbmodels.Comment) (*dbmodels.Comment, error) {
	fake.newCommentMutex.Lock()
	ret, specificReturn := fake.newCommentReturnsOnCall[len(fake.newCommentArgsForCall)]
	fake.newCommentArgsForCall = append(fake.newCommentArgsForCall, struct {
		arg1 context.Context
		arg2 *dbmodels.Comment
	}{arg1, arg2})
	stub := fake.NewCommentStub
	fakeReturns := fake.newCommentReturns
	fake.recordInvocation("NewComment", []interface{}{arg1, arg2})
	fake.newCommentMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeHiveService) NewCommentCallCount() int {
	fake.newCommentMutex.RLock()
	defer fake.newCommentMutex.RUnlock()
	return len(fake.newCommentArgsForCall)
}

func (fake *FakeHiveService) NewCommentCalls(stub func(context.Context, *dbmodels.Comment) (*dbmodels.Comment, error)) {
	fake.newCommentMutex.Lock()
	defer fake.newCommentMutex.Unlock()
	fake.NewCommentStub = stub
}

func (fake *FakeHiveService) NewCommentArgsForCall(i int) (context.Context, *dbmodels.Comment) {
	fake.newCommentMutex.RLock()
	defer fake.newCommentMutex.RUnlock()
	argsForCall := fake.newCommentArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeHiveService) NewCommentReturns(result1 *dbmodels.Comment, result2 error) {
	fake.newCommentMutex.Lock()
	defer fake.newCommentMutex.Unlock()
	fake.NewCommentStub = nil
	fake.newCommentReturns = struct {
		result1 *dbmodels.Comment
		result2 error
	}{result1, result2}
}

func (fake *FakeHiveService) NewCommentReturnsOnCall(i int, result1 *dbmodels.Comment, result2 error) {
	fake.newCommentMutex.Lock()
	defer fake.newCommentMutex.Unlock()
	fake.NewCommentStub = nil
	if fake.newCommentReturnsOnCall == nil {
		fake.newCommentReturnsOnCall = make(map[int]struct {
			result1 *dbmodels.Comment
			result2 error
		})
	}
	fake.newCommentReturnsOnCall[i] = struct {
		result1 *dbmodels.Comment
		result2 error
	}{result1, result2}
}

func (fake *FakeHiveService) NewHive(arg1 context.Context, arg2 *dbmodels.Hive) (*dbmodels.Hive, error) {
	fake.newHiveMutex.Lock()
	ret, specificReturn := fake.newHiveReturnsOnCall[len(fake.newHiveArgsForCall)]
	fake.newHiveArgsForCall = append(fake.newHiveArgsForCall, struct {
		arg1 context.Context
		arg2 *dbmodels.Hive
	}{arg1, arg2})
	stub := fake.NewHiveStub
	fakeReturns := fake.newHiveReturns
	fake.recordInvocation("NewHive", []interface{}{arg1, arg2})
	fake.newHiveMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeHiveService) NewHiveCallCount() int {
	fake.newHiveMutex.RLock()
	defer fake.newHiveMutex.RUnlock()
	return len(fake.newHiveArgsForCall)
}

func (fake *FakeHiveService) NewHiveCalls(stub func(context.Context, *dbmodels.Hive) (*dbmodels.Hive, error)) {
	fake.newHiveMutex.Lock()
	defer fake.newHiveMutex.Unlock()
	fake.NewHiveStub = stub
}

func (fake *FakeHiveService) NewHiveArgsForCall(i int) (context.Context, *dbmodels.Hive) {
	fake.newHiveMutex.RLock()
	defer fake.newHiveMutex.RUnlock()
	argsForCall := fake.newHiveArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeHiveService) NewHiveReturns(result1 *dbmodels.Hive, result2 error) {
	fake.newHiveMutex.Lock()
	defer fake.newHiveMutex.Unlock()
	fake.NewHiveStub = nil
	fake.newHiveReturns = struct {
		result1 *dbmodels.Hive
		result2 error
	}{result1, result2}
}

func (fake *FakeHiveService) NewHiveReturnsOnCall(i int, result1 *dbmodels.Hive, result2 error) {
	fake.newHiveMutex.Lock()
	defer fake.newHiveMutex.Unlock()
	fake.NewHiveStub = nil
	if fake.newHiveReturnsOnCall == nil {
		fake.newHiveReturnsOnCall = make(map[int]struct {
			result1 *dbmodels.Hive
			result2 error
		})
	}
	fake.newHiveReturnsOnCall[i] = struct {
		result1 *dbmodels.Hive
		result2 error
	}{result1, result2}
}

func (fake *FakeHiveService) NewPost(arg1 context.Context, arg2 *dbmodels.Post, arg3 dbmodels.TagSlice) (*dbmodels.Post, error) {
	fake.newPostMutex.Lock()
	ret, specificReturn := fake.newPostReturnsOnCall[len(fake.newPostArgsForCall)]
	fake.newPostArgsForCall = append(fake.newPostArgsForCall, struct {
		arg1 context.Context
		arg2 *dbmodels.Post
		arg3 dbmodels.TagSlice
	}{arg1, arg2, arg3})
	stub := fake.NewPostStub
	fakeReturns := fake.newPostReturns
	fake.recordInvocation("NewPost", []interface{}{arg1, arg2, arg3})
	fake.newPostMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeHiveService) NewPostCallCount() int {
	fake.newPostMutex.RLock()
	defer fake.newPostMutex.RUnlock()
	return len(fake.newPostArgsForCall)
}

func (fake *FakeHiveService) NewPostCalls(stub func(context.Context, *dbmodels.Post, dbmodels.TagSlice) (*dbmodels.Post, error)) {
	fake.newPostMutex.Lock()
	defer fake.newPostMutex.Unlock()
	fake.NewPostStub = stub
}

func (fake *FakeHiveService) NewPostArgsForCall(i int) (context.Context, *dbmodels.Post, dbmodels.TagSlice) {
	fake.newPostMutex.RLock()
	defer fake.newPostMutex.RUnlock()
	argsForCall := fake.newPostArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeHiveService) NewPostReturns(result1 *dbmodels.Post, result2 error) {
	fake.newPostMutex.Lock()
	defer fake.newPostMutex.Unlock()
	fake.NewPostStub = nil
	fake.newPostReturns = struct {
		result1 *dbmodels.Post
		result2 error
	}{result1, result2}
}

func (fake *FakeHiveService) NewPostReturnsOnCall(i int, result1 *dbmodels.Post, result2 error) {
	fake.newPostMutex.Lock()
	defer fake.newPostMutex.Unlock()
	fake.NewPostStub = nil
	if fake.newPostReturnsOnCall == nil {
		fake.newPostReturnsOnCall = make(map[int]struct {
			result1 *dbmodels.Post
			result2 error
		})
	}
	fake.newPostReturnsOnCall[i] = struct {
		result1 *dbmodels.Post
		result2 error
	}{result1, result2}
}

func (fake *FakeHiveService) NewPostVideo(arg1 context.Context, arg2 *dbmodels.PostVideo) (*dbmodels.PostVideo, error) {
	fake.newPostVideoMutex.Lock()
	ret, specificReturn := fake.newPostVideoReturnsOnCall[len(fake.newPostVideoArgsForCall)]
	fake.newPostVideoArgsForCall = append(fake.newPostVideoArgsForCall, struct {
		arg1 context.Context
		arg2 *dbmodels.PostVideo
	}{arg1, arg2})
	stub := fake.NewPostVideoStub
	fakeReturns := fake.newPostVideoReturns
	fake.recordInvocation("NewPostVideo", []interface{}{arg1, arg2})
	fake.newPostVideoMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeHiveService) NewPostVideoCallCount() int {
	fake.newPostVideoMutex.RLock()
	defer fake.newPostVideoMutex.RUnlock()
	return len(fake.newPostVideoArgsForCall)
}

func (fake *FakeHiveService) NewPostVideoCalls(stub func(context.Context, *dbmodels.PostVideo) (*dbmodels.PostVideo, error)) {
	fake.newPostVideoMutex.Lock()
	defer fake.newPostVideoMutex.Unlock()
	fake.NewPostVideoStub = stub
}

func (fake *FakeHiveService) NewPostVideoArgsForCall(i int) (context.Context, *dbmodels.PostVideo) {
	fake.newPostVideoMutex.RLock()
	defer fake.newPostVideoMutex.RUnlock()
	argsForCall := fake.newPostVideoArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeHiveService) NewPostVideoReturns(result1 *dbmodels.PostVideo, result2 error) {
	fake.newPostVideoMutex.Lock()
	defer fake.newPostVideoMutex.Unlock()
	fake.NewPostVideoStub = nil
	fake.newPostVideoReturns = struct {
		result1 *dbmodels.PostVideo
		result2 error
	}{result1, result2}
}

func (fake *FakeHiveService) NewPostVideoReturnsOnCall(i int, result1 *dbmodels.PostVideo, result2 error) {
	fake.newPostVideoMutex.Lock()
	defer fake.newPostVideoMutex.Unlock()
	fake.NewPostVideoStub = nil
	if fake.newPostVideoReturnsOnCall == nil {
		fake.newPostVideoReturnsOnCall = make(map[int]struct {
			result1 *dbmodels.PostVideo
			result2 error
		})
	}
	fake.newPostVideoReturnsOnCall[i] = struct {
		result1 *dbmodels.PostVideo
		result2 error
	}{result1, result2}
}

func (fake *FakeHiveService) PinPost(arg1 context.Context, arg2 uint64, arg3 uint64, arg4 bool) error {
	fake.pinPostMutex.Lock()
	ret, specificReturn := fake.pinPostReturnsOnCall[len(fake.pinPostArgsForCall)]
	fake.pinPostArgsForCall = append(fake.pinPostArgsForCall, struct {
		arg1 context.Context
		arg2 uint64
		arg3 uint64
		arg4 bool
	}{arg1, arg2, arg3, arg4})
	stub := fake.PinPostStub
	fakeReturns := fake.pinPostReturns
	fake.recordInvocation("PinPost", []interface{}{arg1, arg2, arg3, arg4})
	fake.pinPostMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeHiveService) PinPostCallCount() int {
	fake.pinPostMutex.RLock()
	defer fake.pinPostMutex.RUnlock()
	return len(fake.pinPostArgsForCall)
}

func (fake *FakeHiveService) PinPostCalls(stub func(context.Context, uint64, uint64, bool) error) {
	fake.pinPostMutex.Lock()
	defer fake.pinPostMutex.Unlock()
	fake.PinPostStub = stub
}

func (fake *FakeHiveService) PinPostArgsForCall(i int) (context.Context, uint64, uint64, bool) {
	fake.pinPostMutex.RLock()
	defer fake.pinPostMutex.RUnlock()
	argsForCall := fake.pinPostArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeHiveService) PinPostReturns(result1 error) {
	fake.pinPostMutex.Lock()
	defer fake.pinPostMutex.Unlock()
	fake.PinPostStub = nil
	fake.pinPostReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeHiveService) PinPostReturnsOnCall(i int, result1 error) {
	fake.pinPostMutex.Lock()
	defer fake.pinPostMutex.Unlock()
	fake.PinPostStub = nil
	if fake.pinPostReturnsOnCall == nil {
		fake.pinPostReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.pinPostReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeHiveService) ReportComment(arg1 context.Context, arg2 uint64, arg3 *string, arg4 bool) error {
	fake.reportCommentMutex.Lock()
	ret, specificReturn := fake.reportCommentReturnsOnCall[len(fake.reportCommentArgsForCall)]
	fake.reportCommentArgsForCall = append(fake.reportCommentArgsForCall, struct {
		arg1 context.Context
		arg2 uint64
		arg3 *string
		arg4 bool
	}{arg1, arg2, arg3, arg4})
	stub := fake.ReportCommentStub
	fakeReturns := fake.reportCommentReturns
	fake.recordInvocation("ReportComment", []interface{}{arg1, arg2, arg3, arg4})
	fake.reportCommentMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeHiveService) ReportCommentCallCount() int {
	fake.reportCommentMutex.RLock()
	defer fake.reportCommentMutex.RUnlock()
	return len(fake.reportCommentArgsForCall)
}

func (fake *FakeHiveService) ReportCommentCalls(stub func(context.Context, uint64, *string, bool) error) {
	fake.reportCommentMutex.Lock()
	defer fake.reportCommentMutex.Unlock()
	fake.ReportCommentStub = stub
}

func (fake *FakeHiveService) ReportCommentArgsForCall(i int) (context.Context, uint64, *string, bool) {
	fake.reportCommentMutex.RLock()
	defer fake.reportCommentMutex.RUnlock()
	argsForCall := fake.reportCommentArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeHiveService) ReportCommentReturns(result1 error) {
	fake.reportCommentMutex.Lock()
	defer fake.reportCommentMutex.Unlock()
	fake.ReportCommentStub = nil
	fake.reportCommentReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeHiveService) ReportCommentReturnsOnCall(i int, result1 error) {
	fake.reportCommentMutex.Lock()
	defer fake.reportCommentMutex.Unlock()
	fake.ReportCommentStub = nil
	if fake.reportCommentReturnsOnCall == nil {
		fake.reportCommentReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.reportCommentReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeHiveService) ReportPost(arg1 context.Context, arg2 uint64, arg3 *string, arg4 bool) error {
	fake.reportPostMutex.Lock()
	ret, specificReturn := fake.reportPostReturnsOnCall[len(fake.reportPostArgsForCall)]
	fake.reportPostArgsForCall = append(fake.reportPostArgsForCall, struct {
		arg1 context.Context
		arg2 uint64
		arg3 *string
		arg4 bool
	}{arg1, arg2, arg3, arg4})
	stub := fake.ReportPostStub
	fakeReturns := fake.reportPostReturns
	fake.recordInvocation("ReportPost", []interface{}{arg1, arg2, arg3, arg4})
	fake.reportPostMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeHiveService) ReportPostCallCount() int {
	fake.reportPostMutex.RLock()
	defer fake.reportPostMutex.RUnlock()
	return len(fake.reportPostArgsForCall)
}

func (fake *FakeHiveService) ReportPostCalls(stub func(context.Context, uint64, *string, bool) error) {
	fake.reportPostMutex.Lock()
	defer fake.reportPostMutex.Unlock()
	fake.ReportPostStub = stub
}

func (fake *FakeHiveService) ReportPostArgsForCall(i int) (context.Context, uint64, *string, bool) {
	fake.reportPostMutex.RLock()
	defer fake.reportPostMutex.RUnlock()
	argsForCall := fake.reportPostArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeHiveService) ReportPostReturns(result1 error) {
	fake.reportPostMutex.Lock()
	defer fake.reportPostMutex.Unlock()
	fake.ReportPostStub = nil
	fake.reportPostReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeHiveService) ReportPostReturnsOnCall(i int, result1 error) {
	fake.reportPostMutex.Lock()
	defer fake.reportPostMutex.Unlock()
	fake.ReportPostStub = nil
	if fake.reportPostReturnsOnCall == nil {
		fake.reportPostReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.reportPostReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeHiveService) TakeDownVote(arg1 context.Context, arg2 data.ContentInput) error {
	fake.takeDownVoteMutex.Lock()
	ret, specificReturn := fake.takeDownVoteReturnsOnCall[len(fake.takeDownVoteArgsForCall)]
	fake.takeDownVoteArgsForCall = append(fake.takeDownVoteArgsForCall, struct {
		arg1 context.Context
		arg2 data.ContentInput
	}{arg1, arg2})
	stub := fake.TakeDownVoteStub
	fakeReturns := fake.takeDownVoteReturns
	fake.recordInvocation("TakeDownVote", []interface{}{arg1, arg2})
	fake.takeDownVoteMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeHiveService) TakeDownVoteCallCount() int {
	fake.takeDownVoteMutex.RLock()
	defer fake.takeDownVoteMutex.RUnlock()
	return len(fake.takeDownVoteArgsForCall)
}

func (fake *FakeHiveService) TakeDownVoteCalls(stub func(context.Context, data.ContentInput) error) {
	fake.takeDownVoteMutex.Lock()
	defer fake.takeDownVoteMutex.Unlock()
	fake.TakeDownVoteStub = stub
}

func (fake *FakeHiveService) TakeDownVoteArgsForCall(i int) (context.Context, data.ContentInput) {
	fake.takeDownVoteMutex.RLock()
	defer fake.takeDownVoteMutex.RUnlock()
	argsForCall := fake.takeDownVoteArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeHiveService) TakeDownVoteReturns(result1 error) {
	fake.takeDownVoteMutex.Lock()
	defer fake.takeDownVoteMutex.Unlock()
	fake.TakeDownVoteStub = nil
	fake.takeDownVoteReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeHiveService) TakeDownVoteReturnsOnCall(i int, result1 error) {
	fake.takeDownVoteMutex.Lock()
	defer fake.takeDownVoteMutex.Unlock()
	fake.TakeDownVoteStub = nil
	if fake.takeDownVoteReturnsOnCall == nil {
		fake.takeDownVoteReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.takeDownVoteReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeHiveService) TakeUpVote(arg1 context.Context, arg2 data.ContentInput) error {
	fake.takeUpVoteMutex.Lock()
	ret, specificReturn := fake.takeUpVoteReturnsOnCall[len(fake.takeUpVoteArgsForCall)]
	fake.takeUpVoteArgsForCall = append(fake.takeUpVoteArgsForCall, struct {
		arg1 context.Context
		arg2 data.ContentInput
	}{arg1, arg2})
	stub := fake.TakeUpVoteStub
	fakeReturns := fake.takeUpVoteReturns
	fake.recordInvocation("TakeUpVote", []interface{}{arg1, arg2})
	fake.takeUpVoteMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeHiveService) TakeUpVoteCallCount() int {
	fake.takeUpVoteMutex.RLock()
	defer fake.takeUpVoteMutex.RUnlock()
	return len(fake.takeUpVoteArgsForCall)
}

func (fake *FakeHiveService) TakeUpVoteCalls(stub func(context.Context, data.ContentInput) error) {
	fake.takeUpVoteMutex.Lock()
	defer fake.takeUpVoteMutex.Unlock()
	fake.TakeUpVoteStub = stub
}

func (fake *FakeHiveService) TakeUpVoteArgsForCall(i int) (context.Context, data.ContentInput) {
	fake.takeUpVoteMutex.RLock()
	defer fake.takeUpVoteMutex.RUnlock()
	argsForCall := fake.takeUpVoteArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeHiveService) TakeUpVoteReturns(result1 error) {
	fake.takeUpVoteMutex.Lock()
	defer fake.takeUpVoteMutex.Unlock()
	fake.TakeUpVoteStub = nil
	fake.takeUpVoteReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeHiveService) TakeUpVoteReturnsOnCall(i int, result1 error) {
	fake.takeUpVoteMutex.Lock()
	defer fake.takeUpVoteMutex.Unlock()
	fake.TakeUpVoteStub = nil
	if fake.takeUpVoteReturnsOnCall == nil {
		fake.takeUpVoteReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.takeUpVoteReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeHiveService) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.addDownVoteMutex.RLock()
	defer fake.addDownVoteMutex.RUnlock()
	fake.addUpVoteMutex.RLock()
	defer fake.addUpVoteMutex.RUnlock()
	fake.deleteCommentMutex.RLock()
	defer fake.deleteCommentMutex.RUnlock()
	fake.deletePostMutex.RLock()
	defer fake.deletePostMutex.RUnlock()
	fake.editCommentMutex.RLock()
	defer fake.editCommentMutex.RUnlock()
	fake.editHiveMutex.RLock()
	defer fake.editHiveMutex.RUnlock()
	fake.editPostMutex.RLock()
	defer fake.editPostMutex.RUnlock()
	fake.getCommentMutex.RLock()
	defer fake.getCommentMutex.RUnlock()
	fake.getCommentsMutex.RLock()
	defer fake.getCommentsMutex.RUnlock()
	fake.getHiveMutex.RLock()
	defer fake.getHiveMutex.RUnlock()
	fake.getHivesMutex.RLock()
	defer fake.getHivesMutex.RUnlock()
	fake.getPostMutex.RLock()
	defer fake.getPostMutex.RUnlock()
	fake.getPostsMutex.RLock()
	defer fake.getPostsMutex.RUnlock()
	fake.getPostsWithReviewedCommentsMutex.RLock()
	defer fake.getPostsWithReviewedCommentsMutex.RUnlock()
	fake.getPostsWithUnreviewedCommentsMutex.RLock()
	defer fake.getPostsWithUnreviewedCommentsMutex.RUnlock()
	fake.getReportedUserMutex.RLock()
	defer fake.getReportedUserMutex.RUnlock()
	fake.getReviewedPostsMutex.RLock()
	defer fake.getReviewedPostsMutex.RUnlock()
	fake.getUnreviewedReportedPostsMutex.RLock()
	defer fake.getUnreviewedReportedPostsMutex.RUnlock()
	fake.getUserTrackMutex.RLock()
	defer fake.getUserTrackMutex.RUnlock()
	fake.getUserTrackForContentMutex.RLock()
	defer fake.getUserTrackForContentMutex.RUnlock()
	fake.newCommentMutex.RLock()
	defer fake.newCommentMutex.RUnlock()
	fake.newHiveMutex.RLock()
	defer fake.newHiveMutex.RUnlock()
	fake.newPostMutex.RLock()
	defer fake.newPostMutex.RUnlock()
	fake.newPostVideoMutex.RLock()
	defer fake.newPostVideoMutex.RUnlock()
	fake.pinPostMutex.RLock()
	defer fake.pinPostMutex.RUnlock()
	fake.reportCommentMutex.RLock()
	defer fake.reportCommentMutex.RUnlock()
	fake.reportPostMutex.RLock()
	defer fake.reportPostMutex.RUnlock()
	fake.takeDownVoteMutex.RLock()
	defer fake.takeDownVoteMutex.RUnlock()
	fake.takeUpVoteMutex.RLock()
	defer fake.takeUpVoteMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeHiveService) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ data.HiveService = new(FakeHiveService)
