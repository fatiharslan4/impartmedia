// Code generated by SQLBoiler 4.6.0 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package dbmodels

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/volatiletech/null/v8"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/strmangle"
)

// Post is an object representing the database table.
type Post struct {
	PostID         uint64      `boil:"post_id" json:"post_id" toml:"post_id" yaml:"post_id"`
	HiveID         uint64      `boil:"hive_id" json:"hive_id" toml:"hive_id" yaml:"hive_id"`
	ImpartWealthID string      `boil:"impart_wealth_id" json:"impart_wealth_id" toml:"impart_wealth_id" yaml:"impart_wealth_id"`
	Pinned         bool        `boil:"pinned" json:"pinned" toml:"pinned" yaml:"pinned"`
	CreatedAt      time.Time   `boil:"created_at" json:"created_at" toml:"created_at" yaml:"created_at"`
	UpdatedAt      time.Time   `boil:"updated_at" json:"updated_at" toml:"updated_at" yaml:"updated_at"`
	DeletedAt      null.Time   `boil:"deleted_at" json:"deleted_at,omitempty" toml:"deleted_at" yaml:"deleted_at,omitempty"`
	Subject        string      `boil:"subject" json:"subject" toml:"subject" yaml:"subject"`
	Content        string      `boil:"content" json:"content" toml:"content" yaml:"content"`
	LastCommentTS  time.Time   `boil:"last_comment_ts" json:"last_comment_ts" toml:"last_comment_ts" yaml:"last_comment_ts"`
	CommentCount   int         `boil:"comment_count" json:"comment_count" toml:"comment_count" yaml:"comment_count"`
	UpVoteCount    int         `boil:"up_vote_count" json:"up_vote_count" toml:"up_vote_count" yaml:"up_vote_count"`
	DownVoteCount  int         `boil:"down_vote_count" json:"down_vote_count" toml:"down_vote_count" yaml:"down_vote_count"`
	ReportedCount  int         `boil:"reported_count" json:"reported_count" toml:"reported_count" yaml:"reported_count"`
	Obfuscated     bool        `boil:"obfuscated" json:"obfuscated" toml:"obfuscated" yaml:"obfuscated"`
	ReviewedAt     null.Time   `boil:"reviewed_at" json:"reviewed_at,omitempty" toml:"reviewed_at" yaml:"reviewed_at,omitempty"`
	Reviewed       bool        `boil:"reviewed" json:"reviewed" toml:"reviewed" yaml:"reviewed"`
	ReviewComment  null.String `boil:"review_comment" json:"review_comment,omitempty" toml:"review_comment" yaml:"review_comment,omitempty"`

	R *postR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L postL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var PostColumns = struct {
	PostID         string
	HiveID         string
	ImpartWealthID string
	Pinned         string
	CreatedAt      string
	UpdatedAt      string
	DeletedAt      string
	Subject        string
	Content        string
	LastCommentTS  string
	CommentCount   string
	UpVoteCount    string
	DownVoteCount  string
	ReportedCount  string
	Obfuscated     string
	ReviewedAt     string
	Reviewed       string
	ReviewComment  string
}{
	PostID:         "post_id",
	HiveID:         "hive_id",
	ImpartWealthID: "impart_wealth_id",
	Pinned:         "pinned",
	CreatedAt:      "created_at",
	UpdatedAt:      "updated_at",
	DeletedAt:      "deleted_at",
	Subject:        "subject",
	Content:        "content",
	LastCommentTS:  "last_comment_ts",
	CommentCount:   "comment_count",
	UpVoteCount:    "up_vote_count",
	DownVoteCount:  "down_vote_count",
	ReportedCount:  "reported_count",
	Obfuscated:     "obfuscated",
	ReviewedAt:     "reviewed_at",
	Reviewed:       "reviewed",
	ReviewComment:  "review_comment",
}

var PostTableColumns = struct {
	PostID         string
	HiveID         string
	ImpartWealthID string
	Pinned         string
	CreatedAt      string
	UpdatedAt      string
	DeletedAt      string
	Subject        string
	Content        string
	LastCommentTS  string
	CommentCount   string
	UpVoteCount    string
	DownVoteCount  string
	ReportedCount  string
	Obfuscated     string
	ReviewedAt     string
	Reviewed       string
	ReviewComment  string
}{
	PostID:         "post.post_id",
	HiveID:         "post.hive_id",
	ImpartWealthID: "post.impart_wealth_id",
	Pinned:         "post.pinned",
	CreatedAt:      "post.created_at",
	UpdatedAt:      "post.updated_at",
	DeletedAt:      "post.deleted_at",
	Subject:        "post.subject",
	Content:        "post.content",
	LastCommentTS:  "post.last_comment_ts",
	CommentCount:   "post.comment_count",
	UpVoteCount:    "post.up_vote_count",
	DownVoteCount:  "post.down_vote_count",
	ReportedCount:  "post.reported_count",
	Obfuscated:     "post.obfuscated",
	ReviewedAt:     "post.reviewed_at",
	Reviewed:       "post.reviewed",
	ReviewComment:  "post.review_comment",
}

// Generated where

var PostWhere = struct {
	PostID         whereHelperuint64
	HiveID         whereHelperuint64
	ImpartWealthID whereHelperstring
	Pinned         whereHelperbool
	CreatedAt      whereHelpertime_Time
	UpdatedAt      whereHelpertime_Time
	DeletedAt      whereHelpernull_Time
	Subject        whereHelperstring
	Content        whereHelperstring
	LastCommentTS  whereHelpertime_Time
	CommentCount   whereHelperint
	UpVoteCount    whereHelperint
	DownVoteCount  whereHelperint
	ReportedCount  whereHelperint
	Obfuscated     whereHelperbool
	ReviewedAt     whereHelpernull_Time
	Reviewed       whereHelperbool
	ReviewComment  whereHelpernull_String
}{
	PostID:         whereHelperuint64{field: "`post`.`post_id`"},
	HiveID:         whereHelperuint64{field: "`post`.`hive_id`"},
	ImpartWealthID: whereHelperstring{field: "`post`.`impart_wealth_id`"},
	Pinned:         whereHelperbool{field: "`post`.`pinned`"},
	CreatedAt:      whereHelpertime_Time{field: "`post`.`created_at`"},
	UpdatedAt:      whereHelpertime_Time{field: "`post`.`updated_at`"},
	DeletedAt:      whereHelpernull_Time{field: "`post`.`deleted_at`"},
	Subject:        whereHelperstring{field: "`post`.`subject`"},
	Content:        whereHelperstring{field: "`post`.`content`"},
	LastCommentTS:  whereHelpertime_Time{field: "`post`.`last_comment_ts`"},
	CommentCount:   whereHelperint{field: "`post`.`comment_count`"},
	UpVoteCount:    whereHelperint{field: "`post`.`up_vote_count`"},
	DownVoteCount:  whereHelperint{field: "`post`.`down_vote_count`"},
	ReportedCount:  whereHelperint{field: "`post`.`reported_count`"},
	Obfuscated:     whereHelperbool{field: "`post`.`obfuscated`"},
	ReviewedAt:     whereHelpernull_Time{field: "`post`.`reviewed_at`"},
	Reviewed:       whereHelperbool{field: "`post`.`reviewed`"},
	ReviewComment:  whereHelpernull_String{field: "`post`.`review_comment`"},
}

// PostRels is where relationship names are stored.
var PostRels = struct {
	Hive          string
	ImpartWealth  string
	Comments      string
	PostEdits     string
	PostFiles     string
	PostReactions string
	Tags          string
	PostVideos    string
}{
	Hive:          "Hive",
	ImpartWealth:  "ImpartWealth",
	Comments:      "Comments",
	PostEdits:     "PostEdits",
	PostFiles:     "PostFiles",
	PostReactions: "PostReactions",
	Tags:          "Tags",
	PostVideos:    "PostVideos",
}

// postR is where relationships are stored.
type postR struct {
	Hive          *Hive             `boil:"Hive" json:"Hive" toml:"Hive" yaml:"Hive"`
	ImpartWealth  *User             `boil:"ImpartWealth" json:"ImpartWealth" toml:"ImpartWealth" yaml:"ImpartWealth"`
	Comments      CommentSlice      `boil:"Comments" json:"Comments" toml:"Comments" yaml:"Comments"`
	PostEdits     PostEditSlice     `boil:"PostEdits" json:"PostEdits" toml:"PostEdits" yaml:"PostEdits"`
	PostFiles     PostFileSlice     `boil:"PostFiles" json:"PostFiles" toml:"PostFiles" yaml:"PostFiles"`
	PostReactions PostReactionSlice `boil:"PostReactions" json:"PostReactions" toml:"PostReactions" yaml:"PostReactions"`
	Tags          TagSlice          `boil:"Tags" json:"Tags" toml:"Tags" yaml:"Tags"`
	PostVideos    PostVideoSlice    `boil:"PostVideos" json:"PostVideos" toml:"PostVideos" yaml:"PostVideos"`
}

// NewStruct creates a new relationship struct
func (*postR) NewStruct() *postR {
	return &postR{}
}

// postL is where Load methods for each relationship are stored.
type postL struct{}

var (
	postAllColumns            = []string{"post_id", "hive_id", "impart_wealth_id", "pinned", "created_at", "updated_at", "deleted_at", "subject", "content", "last_comment_ts", "comment_count", "up_vote_count", "down_vote_count", "reported_count", "obfuscated", "reviewed_at", "reviewed", "review_comment"}
	postColumnsWithoutDefault = []string{"hive_id", "impart_wealth_id", "pinned", "created_at", "updated_at", "deleted_at", "subject", "content", "last_comment_ts", "reviewed_at", "review_comment"}
	postColumnsWithDefault    = []string{"post_id", "comment_count", "up_vote_count", "down_vote_count", "reported_count", "obfuscated", "reviewed"}
	postPrimaryKeyColumns     = []string{"post_id"}
)

type (
	// PostSlice is an alias for a slice of pointers to Post.
	// This should almost always be used instead of []Post.
	PostSlice []*Post
	// PostHook is the signature for custom Post hook methods
	PostHook func(context.Context, boil.ContextExecutor, *Post) error

	postQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	postType                 = reflect.TypeOf(&Post{})
	postMapping              = queries.MakeStructMapping(postType)
	postPrimaryKeyMapping, _ = queries.BindMapping(postType, postMapping, postPrimaryKeyColumns)
	postInsertCacheMut       sync.RWMutex
	postInsertCache          = make(map[string]insertCache)
	postUpdateCacheMut       sync.RWMutex
	postUpdateCache          = make(map[string]updateCache)
	postUpsertCacheMut       sync.RWMutex
	postUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var postBeforeInsertHooks []PostHook
var postBeforeUpdateHooks []PostHook
var postBeforeDeleteHooks []PostHook
var postBeforeUpsertHooks []PostHook

var postAfterInsertHooks []PostHook
var postAfterSelectHooks []PostHook
var postAfterUpdateHooks []PostHook
var postAfterDeleteHooks []PostHook
var postAfterUpsertHooks []PostHook

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *Post) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range postBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *Post) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range postBeforeUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *Post) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range postBeforeDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *Post) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range postBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *Post) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range postAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterSelectHooks executes all "after Select" hooks.
func (o *Post) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range postAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *Post) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range postAfterUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *Post) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range postAfterDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *Post) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range postAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddPostHook registers your hook function for all future operations.
func AddPostHook(hookPoint boil.HookPoint, postHook PostHook) {
	switch hookPoint {
	case boil.BeforeInsertHook:
		postBeforeInsertHooks = append(postBeforeInsertHooks, postHook)
	case boil.BeforeUpdateHook:
		postBeforeUpdateHooks = append(postBeforeUpdateHooks, postHook)
	case boil.BeforeDeleteHook:
		postBeforeDeleteHooks = append(postBeforeDeleteHooks, postHook)
	case boil.BeforeUpsertHook:
		postBeforeUpsertHooks = append(postBeforeUpsertHooks, postHook)
	case boil.AfterInsertHook:
		postAfterInsertHooks = append(postAfterInsertHooks, postHook)
	case boil.AfterSelectHook:
		postAfterSelectHooks = append(postAfterSelectHooks, postHook)
	case boil.AfterUpdateHook:
		postAfterUpdateHooks = append(postAfterUpdateHooks, postHook)
	case boil.AfterDeleteHook:
		postAfterDeleteHooks = append(postAfterDeleteHooks, postHook)
	case boil.AfterUpsertHook:
		postAfterUpsertHooks = append(postAfterUpsertHooks, postHook)
	}
}

// One returns a single post record from the query.
func (q postQuery) One(ctx context.Context, exec boil.ContextExecutor) (*Post, error) {
	o := &Post{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "dbmodels: failed to execute a one query for post")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all Post records from the query.
func (q postQuery) All(ctx context.Context, exec boil.ContextExecutor) (PostSlice, error) {
	var o []*Post

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "dbmodels: failed to assign all query results to Post slice")
	}

	if len(postAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all Post records in the query.
func (q postQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: failed to count post rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q postQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "dbmodels: failed to check if post exists")
	}

	return count > 0, nil
}

// Hive pointed to by the foreign key.
func (o *Post) Hive(mods ...qm.QueryMod) hiveQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`hive_id` = ?", o.HiveID),
	}

	queryMods = append(queryMods, mods...)

	query := Hives(queryMods...)
	queries.SetFrom(query.Query, "`hive`")

	return query
}

// ImpartWealth pointed to by the foreign key.
func (o *Post) ImpartWealth(mods ...qm.QueryMod) userQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`impart_wealth_id` = ?", o.ImpartWealthID),
		qmhelper.WhereIsNull("deleted_at"),
	}

	queryMods = append(queryMods, mods...)

	query := Users(queryMods...)
	queries.SetFrom(query.Query, "`user`")

	return query
}

// Comments retrieves all the comment's Comments with an executor.
func (o *Post) Comments(mods ...qm.QueryMod) commentQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`comment`.`post_id`=?", o.PostID),
		qmhelper.WhereIsNull("`comment`.`deleted_at`"),
	)

	query := Comments(queryMods...)
	queries.SetFrom(query.Query, "`comment`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`comment`.*"})
	}

	return query
}

// PostEdits retrieves all the post_edit's PostEdits with an executor.
func (o *Post) PostEdits(mods ...qm.QueryMod) postEditQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`post_edits`.`post_id`=?", o.PostID),
		qmhelper.WhereIsNull("`post_edits`.`deleted_at`"),
	)

	query := PostEdits(queryMods...)
	queries.SetFrom(query.Query, "`post_edits`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`post_edits`.*"})
	}

	return query
}

// PostFiles retrieves all the post_file's PostFiles with an executor.
func (o *Post) PostFiles(mods ...qm.QueryMod) postFileQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`post_files`.`post_id`=?", o.PostID),
	)

	query := PostFiles(queryMods...)
	queries.SetFrom(query.Query, "`post_files`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`post_files`.*"})
	}

	return query
}

// PostReactions retrieves all the post_reaction's PostReactions with an executor.
func (o *Post) PostReactions(mods ...qm.QueryMod) postReactionQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`post_reactions`.`post_id`=?", o.PostID),
		qmhelper.WhereIsNull("`post_reactions`.`deleted_at`"),
	)

	query := PostReactions(queryMods...)
	queries.SetFrom(query.Query, "`post_reactions`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`post_reactions`.*"})
	}

	return query
}

// Tags retrieves all the tag's Tags with an executor.
func (o *Post) Tags(mods ...qm.QueryMod) tagQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.InnerJoin("`post_tag` on `tag`.`tag_id` = `post_tag`.`tag_id`"),
		qm.Where("`post_tag`.`post_id`=?", o.PostID),
	)

	query := Tags(queryMods...)
	queries.SetFrom(query.Query, "`tag`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`tag`.*"})
	}

	return query
}

// PostVideos retrieves all the post_video's PostVideos with an executor.
func (o *Post) PostVideos(mods ...qm.QueryMod) postVideoQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`post_videos`.`post_id`=?", o.PostID),
	)

	query := PostVideos(queryMods...)
	queries.SetFrom(query.Query, "`post_videos`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`post_videos`.*"})
	}

	return query
}

// LoadHive allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (postL) LoadHive(ctx context.Context, e boil.ContextExecutor, singular bool, maybePost interface{}, mods queries.Applicator) error {
	var slice []*Post
	var object *Post

	if singular {
		object = maybePost.(*Post)
	} else {
		slice = *maybePost.(*[]*Post)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &postR{}
		}
		args = append(args, object.HiveID)

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &postR{}
			}

			for _, a := range args {
				if a == obj.HiveID {
					continue Outer
				}
			}

			args = append(args, obj.HiveID)

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`hive`),
		qm.WhereIn(`hive.hive_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Hive")
	}

	var resultSlice []*Hive
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Hive")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for hive")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for hive")
	}

	if len(postAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Hive = foreign
		if foreign.R == nil {
			foreign.R = &hiveR{}
		}
		foreign.R.Posts = append(foreign.R.Posts, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.HiveID == foreign.HiveID {
				local.R.Hive = foreign
				if foreign.R == nil {
					foreign.R = &hiveR{}
				}
				foreign.R.Posts = append(foreign.R.Posts, local)
				break
			}
		}
	}

	return nil
}

// LoadImpartWealth allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (postL) LoadImpartWealth(ctx context.Context, e boil.ContextExecutor, singular bool, maybePost interface{}, mods queries.Applicator) error {
	var slice []*Post
	var object *Post

	if singular {
		object = maybePost.(*Post)
	} else {
		slice = *maybePost.(*[]*Post)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &postR{}
		}
		args = append(args, object.ImpartWealthID)

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &postR{}
			}

			for _, a := range args {
				if a == obj.ImpartWealthID {
					continue Outer
				}
			}

			args = append(args, obj.ImpartWealthID)

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`user`),
		qm.WhereIn(`user.impart_wealth_id in ?`, args...),
		qmhelper.WhereIsNull(`user.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load User")
	}

	var resultSlice []*User
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice User")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for user")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for user")
	}

	if len(postAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.ImpartWealth = foreign
		if foreign.R == nil {
			foreign.R = &userR{}
		}
		foreign.R.ImpartWealthPosts = append(foreign.R.ImpartWealthPosts, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.ImpartWealthID == foreign.ImpartWealthID {
				local.R.ImpartWealth = foreign
				if foreign.R == nil {
					foreign.R = &userR{}
				}
				foreign.R.ImpartWealthPosts = append(foreign.R.ImpartWealthPosts, local)
				break
			}
		}
	}

	return nil
}

// LoadComments allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (postL) LoadComments(ctx context.Context, e boil.ContextExecutor, singular bool, maybePost interface{}, mods queries.Applicator) error {
	var slice []*Post
	var object *Post

	if singular {
		object = maybePost.(*Post)
	} else {
		slice = *maybePost.(*[]*Post)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &postR{}
		}
		args = append(args, object.PostID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &postR{}
			}

			for _, a := range args {
				if a == obj.PostID {
					continue Outer
				}
			}

			args = append(args, obj.PostID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`comment`),
		qm.WhereIn(`comment.post_id in ?`, args...),
		qmhelper.WhereIsNull(`comment.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load comment")
	}

	var resultSlice []*Comment
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice comment")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on comment")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for comment")
	}

	if len(commentAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.Comments = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &commentR{}
			}
			foreign.R.Post = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.PostID == foreign.PostID {
				local.R.Comments = append(local.R.Comments, foreign)
				if foreign.R == nil {
					foreign.R = &commentR{}
				}
				foreign.R.Post = local
				break
			}
		}
	}

	return nil
}

// LoadPostEdits allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (postL) LoadPostEdits(ctx context.Context, e boil.ContextExecutor, singular bool, maybePost interface{}, mods queries.Applicator) error {
	var slice []*Post
	var object *Post

	if singular {
		object = maybePost.(*Post)
	} else {
		slice = *maybePost.(*[]*Post)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &postR{}
		}
		args = append(args, object.PostID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &postR{}
			}

			for _, a := range args {
				if a == obj.PostID {
					continue Outer
				}
			}

			args = append(args, obj.PostID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`post_edits`),
		qm.WhereIn(`post_edits.post_id in ?`, args...),
		qmhelper.WhereIsNull(`post_edits.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load post_edits")
	}

	var resultSlice []*PostEdit
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice post_edits")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on post_edits")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for post_edits")
	}

	if len(postEditAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.PostEdits = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &postEditR{}
			}
			foreign.R.Post = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.PostID == foreign.PostID {
				local.R.PostEdits = append(local.R.PostEdits, foreign)
				if foreign.R == nil {
					foreign.R = &postEditR{}
				}
				foreign.R.Post = local
				break
			}
		}
	}

	return nil
}

// LoadPostFiles allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (postL) LoadPostFiles(ctx context.Context, e boil.ContextExecutor, singular bool, maybePost interface{}, mods queries.Applicator) error {
	var slice []*Post
	var object *Post

	if singular {
		object = maybePost.(*Post)
	} else {
		slice = *maybePost.(*[]*Post)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &postR{}
		}
		args = append(args, object.PostID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &postR{}
			}

			for _, a := range args {
				if a == obj.PostID {
					continue Outer
				}
			}

			args = append(args, obj.PostID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`post_files`),
		qm.WhereIn(`post_files.post_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load post_files")
	}

	var resultSlice []*PostFile
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice post_files")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on post_files")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for post_files")
	}

	if len(postFileAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.PostFiles = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &postFileR{}
			}
			foreign.R.Post = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.PostID == foreign.PostID {
				local.R.PostFiles = append(local.R.PostFiles, foreign)
				if foreign.R == nil {
					foreign.R = &postFileR{}
				}
				foreign.R.Post = local
				break
			}
		}
	}

	return nil
}

// LoadPostReactions allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (postL) LoadPostReactions(ctx context.Context, e boil.ContextExecutor, singular bool, maybePost interface{}, mods queries.Applicator) error {
	var slice []*Post
	var object *Post

	if singular {
		object = maybePost.(*Post)
	} else {
		slice = *maybePost.(*[]*Post)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &postR{}
		}
		args = append(args, object.PostID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &postR{}
			}

			for _, a := range args {
				if a == obj.PostID {
					continue Outer
				}
			}

			args = append(args, obj.PostID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`post_reactions`),
		qm.WhereIn(`post_reactions.post_id in ?`, args...),
		qmhelper.WhereIsNull(`post_reactions.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load post_reactions")
	}

	var resultSlice []*PostReaction
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice post_reactions")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on post_reactions")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for post_reactions")
	}

	if len(postReactionAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.PostReactions = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &postReactionR{}
			}
			foreign.R.Post = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.PostID == foreign.PostID {
				local.R.PostReactions = append(local.R.PostReactions, foreign)
				if foreign.R == nil {
					foreign.R = &postReactionR{}
				}
				foreign.R.Post = local
				break
			}
		}
	}

	return nil
}

// LoadTags allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (postL) LoadTags(ctx context.Context, e boil.ContextExecutor, singular bool, maybePost interface{}, mods queries.Applicator) error {
	var slice []*Post
	var object *Post

	if singular {
		object = maybePost.(*Post)
	} else {
		slice = *maybePost.(*[]*Post)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &postR{}
		}
		args = append(args, object.PostID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &postR{}
			}

			for _, a := range args {
				if a == obj.PostID {
					continue Outer
				}
			}

			args = append(args, obj.PostID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.Select("`tag`.tag_id, `tag`.name, `tag`.long_name, `tag`.description, `tag`.sort_order, `a`.`post_id`"),
		qm.From("`tag`"),
		qm.InnerJoin("`post_tag` as `a` on `tag`.`tag_id` = `a`.`tag_id`"),
		qm.WhereIn("`a`.`post_id` in ?", args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load tag")
	}

	var resultSlice []*Tag

	var localJoinCols []uint64
	for results.Next() {
		one := new(Tag)
		var localJoinCol uint64

		err = results.Scan(&one.TagID, &one.Name, &one.LongName, &one.Description, &one.SortOrder, &localJoinCol)
		if err != nil {
			return errors.Wrap(err, "failed to scan eager loaded results for tag")
		}
		if err = results.Err(); err != nil {
			return errors.Wrap(err, "failed to plebian-bind eager loaded slice tag")
		}

		resultSlice = append(resultSlice, one)
		localJoinCols = append(localJoinCols, localJoinCol)
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on tag")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for tag")
	}

	if len(tagAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.Tags = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &tagR{}
			}
			foreign.R.Posts = append(foreign.R.Posts, object)
		}
		return nil
	}

	for i, foreign := range resultSlice {
		localJoinCol := localJoinCols[i]
		for _, local := range slice {
			if local.PostID == localJoinCol {
				local.R.Tags = append(local.R.Tags, foreign)
				if foreign.R == nil {
					foreign.R = &tagR{}
				}
				foreign.R.Posts = append(foreign.R.Posts, local)
				break
			}
		}
	}

	return nil
}

// LoadPostVideos allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (postL) LoadPostVideos(ctx context.Context, e boil.ContextExecutor, singular bool, maybePost interface{}, mods queries.Applicator) error {
	var slice []*Post
	var object *Post

	if singular {
		object = maybePost.(*Post)
	} else {
		slice = *maybePost.(*[]*Post)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &postR{}
		}
		args = append(args, object.PostID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &postR{}
			}

			for _, a := range args {
				if a == obj.PostID {
					continue Outer
				}
			}

			args = append(args, obj.PostID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`post_videos`),
		qm.WhereIn(`post_videos.post_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load post_videos")
	}

	var resultSlice []*PostVideo
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice post_videos")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on post_videos")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for post_videos")
	}

	if len(postVideoAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.PostVideos = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &postVideoR{}
			}
			foreign.R.Post = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.PostID == foreign.PostID {
				local.R.PostVideos = append(local.R.PostVideos, foreign)
				if foreign.R == nil {
					foreign.R = &postVideoR{}
				}
				foreign.R.Post = local
				break
			}
		}
	}

	return nil
}

// SetHive of the post to the related item.
// Sets o.R.Hive to related.
// Adds o to related.R.Posts.
func (o *Post) SetHive(ctx context.Context, exec boil.ContextExecutor, insert bool, related *Hive) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `post` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"hive_id"}),
		strmangle.WhereClause("`", "`", 0, postPrimaryKeyColumns),
	)
	values := []interface{}{related.HiveID, o.PostID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.HiveID = related.HiveID
	if o.R == nil {
		o.R = &postR{
			Hive: related,
		}
	} else {
		o.R.Hive = related
	}

	if related.R == nil {
		related.R = &hiveR{
			Posts: PostSlice{o},
		}
	} else {
		related.R.Posts = append(related.R.Posts, o)
	}

	return nil
}

// SetImpartWealth of the post to the related item.
// Sets o.R.ImpartWealth to related.
// Adds o to related.R.ImpartWealthPosts.
func (o *Post) SetImpartWealth(ctx context.Context, exec boil.ContextExecutor, insert bool, related *User) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `post` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"impart_wealth_id"}),
		strmangle.WhereClause("`", "`", 0, postPrimaryKeyColumns),
	)
	values := []interface{}{related.ImpartWealthID, o.PostID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.ImpartWealthID = related.ImpartWealthID
	if o.R == nil {
		o.R = &postR{
			ImpartWealth: related,
		}
	} else {
		o.R.ImpartWealth = related
	}

	if related.R == nil {
		related.R = &userR{
			ImpartWealthPosts: PostSlice{o},
		}
	} else {
		related.R.ImpartWealthPosts = append(related.R.ImpartWealthPosts, o)
	}

	return nil
}

// AddComments adds the given related objects to the existing relationships
// of the post, optionally inserting them as new records.
// Appends related to o.R.Comments.
// Sets related.R.Post appropriately.
func (o *Post) AddComments(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Comment) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.PostID = o.PostID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `comment` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"post_id"}),
				strmangle.WhereClause("`", "`", 0, commentPrimaryKeyColumns),
			)
			values := []interface{}{o.PostID, rel.CommentID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.PostID = o.PostID
		}
	}

	if o.R == nil {
		o.R = &postR{
			Comments: related,
		}
	} else {
		o.R.Comments = append(o.R.Comments, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &commentR{
				Post: o,
			}
		} else {
			rel.R.Post = o
		}
	}
	return nil
}

// AddPostEdits adds the given related objects to the existing relationships
// of the post, optionally inserting them as new records.
// Appends related to o.R.PostEdits.
// Sets related.R.Post appropriately.
func (o *Post) AddPostEdits(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*PostEdit) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.PostID = o.PostID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `post_edits` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"post_id"}),
				strmangle.WhereClause("`", "`", 0, postEditPrimaryKeyColumns),
			)
			values := []interface{}{o.PostID, rel.PostID, rel.EditID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.PostID = o.PostID
		}
	}

	if o.R == nil {
		o.R = &postR{
			PostEdits: related,
		}
	} else {
		o.R.PostEdits = append(o.R.PostEdits, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &postEditR{
				Post: o,
			}
		} else {
			rel.R.Post = o
		}
	}
	return nil
}

// AddPostFiles adds the given related objects to the existing relationships
// of the post, optionally inserting them as new records.
// Appends related to o.R.PostFiles.
// Sets related.R.Post appropriately.
func (o *Post) AddPostFiles(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*PostFile) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.PostID = o.PostID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `post_files` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"post_id"}),
				strmangle.WhereClause("`", "`", 0, postFilePrimaryKeyColumns),
			)
			values := []interface{}{o.PostID, rel.PFID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.PostID = o.PostID
		}
	}

	if o.R == nil {
		o.R = &postR{
			PostFiles: related,
		}
	} else {
		o.R.PostFiles = append(o.R.PostFiles, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &postFileR{
				Post: o,
			}
		} else {
			rel.R.Post = o
		}
	}
	return nil
}

// AddPostReactions adds the given related objects to the existing relationships
// of the post, optionally inserting them as new records.
// Appends related to o.R.PostReactions.
// Sets related.R.Post appropriately.
func (o *Post) AddPostReactions(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*PostReaction) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.PostID = o.PostID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `post_reactions` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"post_id"}),
				strmangle.WhereClause("`", "`", 0, postReactionPrimaryKeyColumns),
			)
			values := []interface{}{o.PostID, rel.PostID, rel.ImpartWealthID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.PostID = o.PostID
		}
	}

	if o.R == nil {
		o.R = &postR{
			PostReactions: related,
		}
	} else {
		o.R.PostReactions = append(o.R.PostReactions, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &postReactionR{
				Post: o,
			}
		} else {
			rel.R.Post = o
		}
	}
	return nil
}

// AddTags adds the given related objects to the existing relationships
// of the post, optionally inserting them as new records.
// Appends related to o.R.Tags.
// Sets related.R.Posts appropriately.
func (o *Post) AddTags(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Tag) error {
	var err error
	for _, rel := range related {
		if insert {
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		}
	}

	for _, rel := range related {
		query := "insert into `post_tag` (`post_id`, `tag_id`) values (?, ?)"
		values := []interface{}{o.PostID, rel.TagID}

		if boil.IsDebug(ctx) {
			writer := boil.DebugWriterFrom(ctx)
			fmt.Fprintln(writer, query)
			fmt.Fprintln(writer, values)
		}
		_, err = exec.ExecContext(ctx, query, values...)
		if err != nil {
			return errors.Wrap(err, "failed to insert into join table")
		}
	}
	if o.R == nil {
		o.R = &postR{
			Tags: related,
		}
	} else {
		o.R.Tags = append(o.R.Tags, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &tagR{
				Posts: PostSlice{o},
			}
		} else {
			rel.R.Posts = append(rel.R.Posts, o)
		}
	}
	return nil
}

// SetTags removes all previously related items of the
// post replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.Posts's Tags accordingly.
// Replaces o.R.Tags with related.
// Sets related.R.Posts's Tags accordingly.
func (o *Post) SetTags(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Tag) error {
	query := "delete from `post_tag` where `post_id` = ?"
	values := []interface{}{o.PostID}
	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
		fmt.Fprintln(writer, values)
	}
	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	removeTagsFromPostsSlice(o, related)
	if o.R != nil {
		o.R.Tags = nil
	}
	return o.AddTags(ctx, exec, insert, related...)
}

// RemoveTags relationships from objects passed in.
// Removes related items from R.Tags (uses pointer comparison, removal does not keep order)
// Sets related.R.Posts.
func (o *Post) RemoveTags(ctx context.Context, exec boil.ContextExecutor, related ...*Tag) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	query := fmt.Sprintf(
		"delete from `post_tag` where `post_id` = ? and `tag_id` in (%s)",
		strmangle.Placeholders(dialect.UseIndexPlaceholders, len(related), 2, 1),
	)
	values := []interface{}{o.PostID}
	for _, rel := range related {
		values = append(values, rel.TagID)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
		fmt.Fprintln(writer, values)
	}
	_, err = exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}
	removeTagsFromPostsSlice(o, related)
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.Tags {
			if rel != ri {
				continue
			}

			ln := len(o.R.Tags)
			if ln > 1 && i < ln-1 {
				o.R.Tags[i] = o.R.Tags[ln-1]
			}
			o.R.Tags = o.R.Tags[:ln-1]
			break
		}
	}

	return nil
}

func removeTagsFromPostsSlice(o *Post, related []*Tag) {
	for _, rel := range related {
		if rel.R == nil {
			continue
		}
		for i, ri := range rel.R.Posts {
			if o.PostID != ri.PostID {
				continue
			}

			ln := len(rel.R.Posts)
			if ln > 1 && i < ln-1 {
				rel.R.Posts[i] = rel.R.Posts[ln-1]
			}
			rel.R.Posts = rel.R.Posts[:ln-1]
			break
		}
	}
}

// AddPostVideos adds the given related objects to the existing relationships
// of the post, optionally inserting them as new records.
// Appends related to o.R.PostVideos.
// Sets related.R.Post appropriately.
func (o *Post) AddPostVideos(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*PostVideo) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.PostID = o.PostID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `post_videos` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"post_id"}),
				strmangle.WhereClause("`", "`", 0, postVideoPrimaryKeyColumns),
			)
			values := []interface{}{o.PostID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.PostID = o.PostID
		}
	}

	if o.R == nil {
		o.R = &postR{
			PostVideos: related,
		}
	} else {
		o.R.PostVideos = append(o.R.PostVideos, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &postVideoR{
				Post: o,
			}
		} else {
			rel.R.Post = o
		}
	}
	return nil
}

// Posts retrieves all the records using an executor.
func Posts(mods ...qm.QueryMod) postQuery {
	mods = append(mods, qm.From("`post`"), qmhelper.WhereIsNull("`post`.`deleted_at`"))
	return postQuery{NewQuery(mods...)}
}

// FindPost retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindPost(ctx context.Context, exec boil.ContextExecutor, postID uint64, selectCols ...string) (*Post, error) {
	postObj := &Post{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from `post` where `post_id`=? and `deleted_at` is null", sel,
	)

	q := queries.Raw(query, postID)

	err := q.Bind(ctx, exec, postObj)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "dbmodels: unable to select from post")
	}

	if err = postObj.doAfterSelectHooks(ctx, exec); err != nil {
		return postObj, err
	}

	return postObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *Post) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("dbmodels: no post provided for insertion")
	}

	var err error
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		if o.CreatedAt.IsZero() {
			o.CreatedAt = currTime
		}
		if o.UpdatedAt.IsZero() {
			o.UpdatedAt = currTime
		}
	}

	if err := o.doBeforeInsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(postColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	postInsertCacheMut.RLock()
	cache, cached := postInsertCache[key]
	postInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			postAllColumns,
			postColumnsWithDefault,
			postColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(postType, postMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(postType, postMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO `post` (`%s`) %%sVALUES (%s)%%s", strings.Join(wl, "`,`"), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO `post` () VALUES ()%s%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			cache.retQuery = fmt.Sprintf("SELECT `%s` FROM `post` WHERE %s", strings.Join(returnColumns, "`,`"), strmangle.WhereClause("`", "`", 0, postPrimaryKeyColumns))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	result, err := exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "dbmodels: unable to insert into post")
	}

	var lastID int64
	var identifierCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	lastID, err = result.LastInsertId()
	if err != nil {
		return ErrSyncFail
	}

	o.PostID = uint64(lastID)
	if lastID != 0 && len(cache.retMapping) == 1 && cache.retMapping[0] == postMapping["post_id"] {
		goto CacheNoHooks
	}

	identifierCols = []interface{}{
		o.PostID,
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.retQuery)
		fmt.Fprintln(writer, identifierCols...)
	}
	err = exec.QueryRowContext(ctx, cache.retQuery, identifierCols...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	if err != nil {
		return errors.Wrap(err, "dbmodels: unable to populate default values for post")
	}

CacheNoHooks:
	if !cached {
		postInsertCacheMut.Lock()
		postInsertCache[key] = cache
		postInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(ctx, exec)
}

// Update uses an executor to update the Post.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *Post) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		o.UpdatedAt = currTime
	}

	var err error
	if err = o.doBeforeUpdateHooks(ctx, exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	postUpdateCacheMut.RLock()
	cache, cached := postUpdateCache[key]
	postUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			postAllColumns,
			postPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("dbmodels: unable to update post, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE `post` SET %s WHERE %s",
			strmangle.SetParamNames("`", "`", 0, wl),
			strmangle.WhereClause("`", "`", 0, postPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(postType, postMapping, append(wl, postPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, values)
	}
	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: unable to update post row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: failed to get rows affected by update for post")
	}

	if !cached {
		postUpdateCacheMut.Lock()
		postUpdateCache[key] = cache
		postUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(ctx, exec)
}

// UpdateAll updates all rows with the specified column values.
func (q postQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: unable to update all for post")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: unable to retrieve rows affected for post")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o PostSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("dbmodels: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), postPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE `post` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, postPrimaryKeyColumns, len(o)))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: unable to update all in post slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: unable to retrieve rows affected all in update all post")
	}
	return rowsAff, nil
}

var mySQLPostUniqueColumns = []string{
	"post_id",
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *Post) Upsert(ctx context.Context, exec boil.ContextExecutor, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("dbmodels: no post provided for upsert")
	}
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		if o.CreatedAt.IsZero() {
			o.CreatedAt = currTime
		}
		o.UpdatedAt = currTime
	}

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(postColumnsWithDefault, o)
	nzUniques := queries.NonZeroDefaultSet(mySQLPostUniqueColumns, o)

	if len(nzUniques) == 0 {
		return errors.New("cannot upsert with a table that cannot conflict on a unique column")
	}

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzUniques {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	postUpsertCacheMut.RLock()
	cache, cached := postUpsertCache[key]
	postUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			postAllColumns,
			postColumnsWithDefault,
			postColumnsWithoutDefault,
			nzDefaults,
		)
		update := updateColumns.UpdateColumnSet(
			postAllColumns,
			postPrimaryKeyColumns,
		)

		if !updateColumns.IsNone() && len(update) == 0 {
			return errors.New("dbmodels: unable to upsert post, could not build update column list")
		}

		ret = strmangle.SetComplement(ret, nzUniques)
		cache.query = buildUpsertQueryMySQL(dialect, "`post`", update, insert)
		cache.retQuery = fmt.Sprintf(
			"SELECT %s FROM `post` WHERE %s",
			strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, ret), ","),
			strmangle.WhereClause("`", "`", 0, nzUniques),
		)

		cache.valueMapping, err = queries.BindMapping(postType, postMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(postType, postMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	result, err := exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "dbmodels: unable to upsert for post")
	}

	var lastID int64
	var uniqueMap []uint64
	var nzUniqueCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	lastID, err = result.LastInsertId()
	if err != nil {
		return ErrSyncFail
	}

	o.PostID = uint64(lastID)
	if lastID != 0 && len(cache.retMapping) == 1 && cache.retMapping[0] == postMapping["post_id"] {
		goto CacheNoHooks
	}

	uniqueMap, err = queries.BindMapping(postType, postMapping, nzUniques)
	if err != nil {
		return errors.Wrap(err, "dbmodels: unable to retrieve unique values for post")
	}
	nzUniqueCols = queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), uniqueMap)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.retQuery)
		fmt.Fprintln(writer, nzUniqueCols...)
	}
	err = exec.QueryRowContext(ctx, cache.retQuery, nzUniqueCols...).Scan(returns...)
	if err != nil {
		return errors.Wrap(err, "dbmodels: unable to populate default values for post")
	}

CacheNoHooks:
	if !cached {
		postUpsertCacheMut.Lock()
		postUpsertCache[key] = cache
		postUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}

// Delete deletes a single Post record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *Post) Delete(ctx context.Context, exec boil.ContextExecutor, hardDelete bool) (int64, error) {
	if o == nil {
		return 0, errors.New("dbmodels: no Post provided for delete")
	}

	if err := o.doBeforeDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	var (
		sql  string
		args []interface{}
	)
	if hardDelete {
		args = queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), postPrimaryKeyMapping)
		sql = "DELETE FROM `post` WHERE `post_id`=?"
	} else {
		currTime := time.Now().In(boil.GetLocation())
		o.DeletedAt = null.TimeFrom(currTime)
		wl := []string{"deleted_at"}
		sql = fmt.Sprintf("UPDATE `post` SET %s WHERE `post_id`=?",
			strmangle.SetParamNames("`", "`", 0, wl),
		)
		valueMapping, err := queries.BindMapping(postType, postMapping, append(wl, postPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
		args = queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), valueMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: unable to delete from post")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: failed to get rows affected by delete for post")
	}

	if err := o.doAfterDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q postQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor, hardDelete bool) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("dbmodels: no postQuery provided for delete all")
	}

	if hardDelete {
		queries.SetDelete(q.Query)
	} else {
		currTime := time.Now().In(boil.GetLocation())
		queries.SetUpdate(q.Query, M{"deleted_at": currTime})
	}

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: unable to delete all from post")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: failed to get rows affected by deleteall for post")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o PostSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor, hardDelete bool) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	if len(postBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	var (
		sql  string
		args []interface{}
	)
	if hardDelete {
		for _, obj := range o {
			pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), postPrimaryKeyMapping)
			args = append(args, pkeyArgs...)
		}
		sql = "DELETE FROM `post` WHERE " +
			strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, postPrimaryKeyColumns, len(o))
	} else {
		currTime := time.Now().In(boil.GetLocation())
		for _, obj := range o {
			pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), postPrimaryKeyMapping)
			args = append(args, pkeyArgs...)
			obj.DeletedAt = null.TimeFrom(currTime)
		}
		wl := []string{"deleted_at"}
		sql = fmt.Sprintf("UPDATE `post` SET %s WHERE "+
			strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, postPrimaryKeyColumns, len(o)),
			strmangle.SetParamNames("`", "`", 0, wl),
		)
		args = append([]interface{}{currTime}, args...)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: unable to delete all from post slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: failed to get rows affected by deleteall for post")
	}

	if len(postAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *Post) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindPost(ctx, exec, o.PostID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *PostSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := PostSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), postPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT `post`.* FROM `post` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, postPrimaryKeyColumns, len(*o)) +
		"and `deleted_at` is null"

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "dbmodels: unable to reload all in PostSlice")
	}

	*o = slice

	return nil
}

// PostExists checks if the Post row exists.
func PostExists(ctx context.Context, exec boil.ContextExecutor, postID uint64) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from `post` where `post_id`=? and `deleted_at` is null limit 1)"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, postID)
	}
	row := exec.QueryRowContext(ctx, sql, postID)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "dbmodels: unable to check if post exists")
	}

	return exists, nil
}
